---
phase: 05-code-review-and-verification
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - agents/mz-verifier.md
  - skills/verify/SKILL.md
  - skills/verify/verifier.md
  - skills/review/SKILL.md
  - commands/review.md
  - commands/verify.md
  - skills/help/SKILL.md
autonomous: true
requirements: [QUAL-01, QUAL-06]

must_haves:
  truths:
    - "A verifier agent definition exists that performs goal-backward verification against ROADMAP.md success criteria and PLAN.md must_haves"
    - "The verifier checks truths, artifacts (exists + substantive + wired), and key links against the actual codebase"
    - "Running /mz:verify spawns a verifier subagent, generates VERIFICATION.md, and blocks phase transition on failure"
    - "/mz:verify uses hybrid mode: automated checks first, then user confirmation only for ambiguous or subjective criteria"
    - "/mz:verify checks that all plans in the phase are complete (have SUMMARY.md) before verifying"
    - "Running /mz:review triggers a standalone two-stage code review on demand, regardless of config setting"
    - "/mz:review can target specific files, a plan, or the latest changes"
    - "Both /mz:review and /mz:verify are listed as Available in /mz:help (not Coming soon)"
    - "Autocomplete proxy files exist for both review and verify commands"
  artifacts:
    - path: "agents/mz-verifier.md"
      provides: "Phase verification agent with goal-backward analysis, 3-level artifact checking, and hybrid verification mode"
      min_lines: 120
    - path: "skills/verify/SKILL.md"
      provides: "Full /mz:verify orchestrator skill replacing stub"
      min_lines: 150
    - path: "skills/verify/verifier.md"
      provides: "Supporting file with verification protocol reference"
      min_lines: 40
    - path: "skills/review/SKILL.md"
      provides: "Full /mz:review standalone skill replacing stub"
      min_lines: 80
    - path: "commands/review.md"
      provides: "Autocomplete proxy for /mz:review"
      min_lines: 3
    - path: "commands/verify.md"
      provides: "Autocomplete proxy for /mz:verify"
      min_lines: 3
    - path: "skills/help/SKILL.md"
      provides: "Updated help with /mz:review and /mz:verify as Available"
      min_lines: 50
  key_links:
    - from: "skills/verify/SKILL.md"
      to: "agents/mz-verifier.md"
      via: "Reads verifier agent definition and embeds in Task prompt"
      pattern: "agents/mz-verifier.md"
    - from: "skills/verify/SKILL.md"
      to: "src/lib/plan.ts"
      via: "Uses CLI tools for plan listing and completion checking"
      pattern: "megazord.mjs tools plan"
    - from: "skills/review/SKILL.md"
      to: "agents/mz-reviewer.md"
      via: "Reads reviewer agent definition and embeds in Task prompt"
      pattern: "agents/mz-reviewer.md"
    - from: "skills/help/SKILL.md"
      to: "skills/review/SKILL.md"
      via: "Lists /mz:review as Available skill"
      pattern: "/mz:review"
    - from: "skills/help/SKILL.md"
      to: "skills/verify/SKILL.md"
      via: "Lists /mz:verify as Available skill"
      pattern: "/mz:verify"
---

<objective>
Create the verifier agent, /mz:verify orchestrator skill, /mz:review standalone skill, and update help and command proxies. The verifier agent performs goal-backward verification of phase deliverables against ROADMAP.md success criteria and PLAN.md must_haves. The /mz:verify skill orchestrates verification with hybrid mode (automated + user confirmation). The /mz:review skill provides on-demand two-stage code review independent of the /mz:go pipeline.

Purpose: This completes Phase 5's quality gates: (1) /mz:verify ensures phase deliverables actually achieve the goal before marking the phase complete, and (2) /mz:review gives developers manual access to the two-stage review at any time. Together with Plan 01's automated review integration, these form a comprehensive quality assurance system.

Output: `agents/mz-verifier.md`, `skills/verify/SKILL.md`, `skills/verify/verifier.md`, `skills/review/SKILL.md`, `commands/review.md`, `commands/verify.md`, updated `skills/help/SKILL.md`
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@agents/mz-reviewer.md
@agents/mz-executor.md
@skills/go/SKILL.md
@skills/go/executor.md
@skills/verify/SKILL.md
@skills/review/SKILL.md
@skills/help/SKILL.md
@skills/init/design-system.md
@.planning/megazord.config.json
@.planning/phases/05-code-review-and-verification/05-RESEARCH.md
@.planning/phases/05-code-review-and-verification/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create verifier agent and /mz:verify orchestrator skill</name>
  <files>
agents/mz-verifier.md
skills/verify/SKILL.md
skills/verify/verifier.md
  </files>
  <action>
**1. Create `agents/mz-verifier.md`** -- Phase verification agent adapted from GSD's `gsd-verifier.md` but using Megazord conventions and CLI tools.

Structure the agent definition with these sections:

**# Megazord Phase Verifier**

**## Your Objective**
Verify that a phase achieved its GOAL, not just completed its TASKS. Perform goal-backward verification starting from what the phase SHOULD deliver, verifying it actually exists and works in the codebase. Write VERIFICATION.md with results.

**## Critical Mindset**
Do NOT trust SUMMARY.md claims. SUMMARYs document what Claude SAID it did. You verify what ACTUALLY exists in the code. These often differ. Task completion does not equal goal achievement.

**## Input**
You receive embedded inline in the Task prompt:
- `<phase_goal>`: Phase goal from ROADMAP.md
- `<success_criteria>`: Success criteria list from ROADMAP.md
- `<plans>`: For each PLAN.md: filename, must_haves from frontmatter, requirements
- `<summaries>`: For each SUMMARY.md: filename, key accomplishments, key files, decisions
- `<requirements>`: Requirement IDs mapped to this phase
- `<verification_rules>`: Phase number, phase directory, report path, mode (hybrid)

**## Verification Process**

### Step 1: Establish Must-Haves
Combine must-haves from two sources:
1. **ROADMAP.md success criteria** -- each criterion becomes a truth to verify
2. **PLAN.md must_haves** -- truths, artifacts, and key_links from plan frontmatter

Deduplicate where overlap exists (plans often refine roadmap criteria).

### Step 2: Verify Truths
For each truth (observable behavior that must be TRUE):
1. Determine what evidence proves this truth
2. Check the codebase for that evidence using Read, Grep, Glob, Bash
3. Mark as: PASSED, FAILED, or UNCERTAIN (needs human verification)

For UNCERTAIN items: document what was checked and why it's ambiguous. These will be presented to the user in hybrid mode.

### Step 3: Verify Artifacts (3-Level Check)
For each artifact in must_haves:

**Level 1 - Exists:** Does the file exist at the specified path?
```bash
[ -f "{path}" ] && echo "EXISTS" || echo "MISSING"
```

**Level 2 - Substantive:** Is the file meaningful (not a stub/placeholder)?
- Check min_lines if specified: `wc -l < "{path}"`
- Check for expected content using Grep (exports, contains, provides fields)
- Check it's not just comments or placeholder text

**Level 3 - Wired:** Is the artifact connected to the rest of the system?
- Check imports/references from other files
- Check that exports are consumed
- Check route registration, config references, etc.

### Step 4: Verify Key Links
For each key_link in must_haves:
1. Check the `from` file exists
2. Check the `to` file/endpoint exists
3. Use Grep with the `pattern` to verify the connection:
   ```bash
   grep -r "{pattern}" "{from_file}"
   ```
4. Mark as: WIRED (pattern found), BROKEN (pattern not found), or UNCERTAIN

### Step 5: Verify Requirements Coverage
For each requirement ID mapped to this phase:
1. Check it appears in at least one plan's `requirements` frontmatter
2. Check the plan that claims it has a SUMMARY.md (was executed)
3. Verify the requirement's intent is satisfied in the codebase

### Step 6: Scan for Anti-Patterns
Check the phase directory and affected files for common issues:
- Stub files still containing placeholder content
- TODO/FIXME comments in shipped code
- Unused imports or dead code in new files
- Missing error handling in new endpoints/functions

### Step 7: Identify Human Verification Needs
Collect all UNCERTAIN items from Steps 2-4. These require user confirmation because:
- Visual/UI verification (cannot be automated)
- Subjective quality judgment
- External service integration testing
- User experience validation

### Step 8: Write VERIFICATION.md
Write to the path specified in `<verification_rules>` using the Write tool.

Report format:
```markdown
---
phase: {phase-slug}
phase_number: {N}
verified: {ISO timestamp}
status: passed | gaps_found | human_needed
truths_passed: {count}
truths_failed: {count}
truths_uncertain: {count}
artifacts_passed: {count}
artifacts_failed: {count}
key_links_wired: {count}
key_links_broken: {count}
requirements_covered: {count}
requirements_missing: {count}
---

# Verification: Phase {N} - {Name}

## Phase Goal
{goal from ROADMAP.md}

## Truths Verification

| # | Truth | Status | Evidence |
|---|-------|--------|----------|
| 1 | {truth} | PASSED/FAILED/UNCERTAIN | {what was checked} |

## Artifacts Verification

| # | Artifact | Exists | Substantive | Wired | Status |
|---|----------|--------|-------------|-------|--------|
| 1 | {path} | Y/N | Y/N | Y/N | PASSED/FAILED |

## Key Links Verification

| # | From | To | Via | Status |
|---|------|----|-----|--------|
| 1 | {from} | {to} | {via} | WIRED/BROKEN |

## Requirements Coverage

| ID | Description | Covered | Plan |
|----|-------------|---------|------|
| {ID} | {desc} | Y/N | {plan that covers it} |

## Anti-Pattern Scan
{findings or "No anti-patterns detected."}

## Human Verification Needed
{list of UNCERTAIN items for user confirmation, or "None -- all checks are automated."}

## Gaps
{list of FAILED items with details, or "No gaps found."}

## Result
**Status:** {passed | gaps_found | human_needed}
{summary of findings}
```

**## Return Format**
Return this exact structure:

```markdown
## VERIFICATION COMPLETE

**Phase:** {phase_number}
**Status:** passed | gaps_found | human_needed
**Truths:** {passed}/{total} ({uncertain} uncertain)
**Artifacts:** {passed}/{total}
**Key Links:** {wired}/{total}
**Requirements:** {covered}/{total}

### Gaps
{list of failed items, or "None"}

### Human Verification Needed
{list of uncertain items, or "None"}
```

**## Rules**
- Do NOT trust SUMMARY.md claims -- verify against actual code
- Do NOT fix any issues -- you verify only, report gaps
- Do NOT update STATE.md or ROADMAP.md
- ALWAYS write VERIFICATION.md using the Write tool
- ALWAYS use bun/bunx for any JavaScript/TypeScript operations
- Use Read, Grep, Glob, and Bash to check the actual codebase

**2. Replace `skills/verify/SKILL.md`** (currently a stub) with the full /mz:verify orchestrator skill.

Frontmatter:
```yaml
---
name: verify
description: Verify phase deliverables match acceptance criteria
disable-model-invocation: false
---
```

Reference supporting files:
```
Reference @skills/init/design-system.md for visual output formatting.
Reference @skills/verify/verifier.md for verification protocol and spawning patterns.
```

**Step 1: Display Banner**
```
+===============================================+
|  MEGAZORD > VERIFY                            |
+===============================================+
```

**Step 2: Load Context and Validate**
- Read `.planning/megazord.config.json`. If missing, display error and stop (same pattern as /mz:go).
- Read `.planning/STATE.md` for current position.
- Read `.planning/ROADMAP.md` for phase details and success criteria.
- Parse the user's message (text after `/mz:verify`) for arguments:
  - `{phase_num}` -- verify a specific phase (optional, defaults to current)
  - `--partial` -- verify even if some plans are incomplete (skip completion check)
- Determine the plugin path for CLI commands.

**Step 3: Determine Target Phase**
- If phase number argument provided: use that phase.
- Otherwise: use current phase from STATE.md.
- Compute the phase directory path.
- Extract phase goal and success criteria from ROADMAP.md.

**Step 4: Check Plan Completion**
```bash
node {plugin_path}/bin/megazord.mjs tools plan incomplete --phase-dir {phase_dir}
```
- If incomplete plans exist AND `--partial` was NOT provided:
  Display warning listing incomplete plans. Ask user whether to proceed with partial verification or wait.
- If incomplete plans exist AND `--partial` was provided: proceed with note.
- If all plans complete: proceed to verification.

**Step 5: Spawn Verifier**
1. Read all PLAN.md files in the phase directory (extract must_haves from frontmatter for each).
2. Read all SUMMARY.md files in the phase directory (extract key accomplishments, files, decisions).
3. Read `agents/mz-verifier.md` content.
4. Extract requirement IDs from the phase's ROADMAP.md entry.
5. Compose the Task prompt:
```
<agent_role>
{content of agents/mz-verifier.md}
</agent_role>

<phase_goal>
{Phase goal from ROADMAP.md}
</phase_goal>

<success_criteria>
{Success criteria list from ROADMAP.md, numbered}
</success_criteria>

<plans>
{For each PLAN.md: filename, must_haves section, requirements field}
</plans>

<summaries>
{For each SUMMARY.md: filename, key accomplishments section, key-files, key-decisions}
</summaries>

<requirements>
{Requirement IDs mapped to this phase with their descriptions}
</requirements>

<verification_rules>
- Phase: {phase_number}
- Phase directory: {phase_dir}
- Report path: {phase_dir}/{padded}-VERIFICATION.md
- Mode: hybrid (automated first, user confirmation for ambiguous)
- Criteria sources: ROADMAP.md success criteria + PLAN.md must_haves
</verification_rules>
```

6. Spawn via Task tool:
   - `subagent_type`: `"general-purpose"`
   - `description`: `"Verify Phase {phase_number}: {phase name}"`

7. Wait for completion.

8. Parse the structured result (look for `## VERIFICATION COMPLETE`).

**Step 6: Handle Result**

Parse the verification status:

- **passed**: All truths verified, all artifacts exist and are wired, all requirements covered.
  - Display success:
    ```
    +===============================================+
    |  Phase {N} Verification: PASSED              |
    +===============================================+
    |  Truths: {N}/{N} passed                      |
    |  Artifacts: {N}/{N} verified                 |
    |  Key Links: {N}/{N} wired                    |
    |  Requirements: {N}/{N} covered               |
    +===============================================+
    ```
  - Suggest advancing to next phase.

- **gaps_found**: Some truths failed, artifacts missing, or requirements uncovered.
  - Display gaps clearly with details from VERIFICATION.md.
  - Suggest running `/mz:go --gaps` or re-planning to address gaps.
  - Do NOT auto-advance the phase.

- **human_needed**: Some items need user confirmation.
  - Display the automated results (passed/failed items).
  - Present each UNCERTAIN item to the user one at a time:
    ```
    > Human Verification Needed

    1. {uncertain truth/artifact description}
       Evidence checked: {what was verified}
       Question: Does this satisfy the criteria? (yes/no/partial)
    ```
  - Collect user responses.
  - Update the overall status based on responses.
  - Re-write VERIFICATION.md with user confirmations included.

**Step 7: Post-Verification Summary**
Display Next Up block:
- If passed: "Phase {N} verified. Ready for Phase {N+1}. Run `/mz:plan` to plan the next phase."
- If gaps_found: "Address gaps first. Run `/mz:go` to fix, or `/mz:plan --gaps` for gap closure plans."
- If human_needed (after user confirms all): Update and proceed as passed or gaps_found.

**3. Create `skills/verify/verifier.md`** -- Supporting file referenced by the skill.

Content should cover:
- Verification protocol: how the orchestrator reads verifier agent definition and phase context, embeds inline in Task prompt
- Prompt structure for verifier: `<agent_role>`, `<phase_goal>`, `<success_criteria>`, `<plans>`, `<summaries>`, `<requirements>`, `<verification_rules>` sections
- Critical constraint: @file references do NOT work across Task boundaries (same pattern as go/executor.md)
- Hybrid mode protocol: how UNCERTAIN items are handled by the orchestrator after verifier completes
- State update protocol: only the orchestrator updates state after verification
  </action>
  <verify>
1. agents/mz-verifier.md exists with: goal-backward verification, 3-level artifact checking (exists, substantive, wired), key link verification, requirements coverage, VERIFICATION.md creation, "VERIFICATION COMPLETE" return format (at least 120 lines)
2. skills/verify/SKILL.md has `disable-model-invocation: false`, 7 steps, references verifier.md and design-system.md, handles passed/gaps_found/human_needed statuses
3. skills/verify/verifier.md exists with verification protocol, prompt structure, hybrid mode documentation
4. No npm/npx references in any new file
5. agents/mz-verifier.md specifies: verify only (no fixing), do not trust SUMMARY.md, check actual codebase
  </verify>
  <done>
The /mz:verify skill is a complete verification orchestrator that spawns a verifier subagent to perform goal-backward verification of phase deliverables. The verifier checks truths, artifacts (3-level: exists, substantive, wired), key links, and requirement coverage against the actual codebase. VERIFICATION.md is persisted. Hybrid mode presents ambiguous items to the user for confirmation. The phase cannot transition to complete until verification passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /mz:review standalone skill, command proxies, and update help</name>
  <files>
skills/review/SKILL.md
commands/review.md
commands/verify.md
skills/help/SKILL.md
  </files>
  <action>
**1. Replace `skills/review/SKILL.md`** (currently a stub) with the full standalone /mz:review skill.

This skill provides on-demand two-stage code review independent of the /mz:go pipeline. Users can trigger it manually at any time, regardless of the `quality.review` config setting.

Frontmatter:
```yaml
---
name: review
description: Two-stage code review (spec compliance + code quality)
disable-model-invocation: false
---
```

Reference supporting files:
```
Reference @skills/init/design-system.md for visual output formatting.
Reference @agents/mz-reviewer.md for the review agent definition.
```

**Step 1: Display Banner**
```
+===============================================+
|  MEGAZORD > REVIEW                            |
+===============================================+
```

**Step 2: Parse Arguments and Determine Scope**
Parse the user's message (text after `/mz:review`) for the review target:

- `/mz:review` (no args) -- review the most recent commit's changes
- `/mz:review --plan {phase}-{plan}` -- review all changes from a specific plan (diff from before plan started to after plan completed)
- `/mz:review --files path/to/file.ts path/to/other.ts` -- review specific files (diff of uncommitted changes, or latest commit affecting those files)
- `/mz:review --last N` -- review the last N commits

Determine the diff to review based on the scope:
- No args: `git diff HEAD~1 HEAD`
- --plan: compute diff range from plan's first to last commit (read SUMMARY.md for commit hashes)
- --files: `git diff HEAD -- {files}` (uncommitted) or `git log -1 --format=%H -- {files}` then diff
- --last N: `git diff HEAD~{N} HEAD`

**Step 3: Load Context**
- Read `.planning/megazord.config.json` (optional -- review works even without config).
- If a plan is specified, read the PLAN.md for task definitions and requirements context.
- Read `agents/mz-reviewer.md` content.
- Determine the plugin path for CLI commands.

**Step 4: Prepare Review Context**
1. Get the diff based on the scope determined in Step 2.
2. Identify affected files from the diff.
3. Read each affected file's full content (skip if diff > 300 lines).
4. If plan context available: extract task definitions and requirements.
5. Determine the report output path:
   - If within a phase: `{phase_dir}/{padded}-{plan}-REVIEW-manual.md`
   - If no phase context: `.planning/reviews/REVIEW-{timestamp}.md`

**Step 5: Spawn Reviewer**
Compose the Task prompt and spawn the reviewer subagent:
```
<agent_role>
{content of agents/mz-reviewer.md}
</agent_role>

<task_definition>
{plan task definition if available, or "Manual review -- no plan context"}
</task_definition>

<diff>
{the computed diff}
</diff>

<affected_files>
{full content of affected files, if diff <= 300 lines}
</affected_files>

<plan_requirements>
{requirements from plan if available, or "Manual review -- no plan requirements"}
</plan_requirements>

<review_rules>
- Phase: {phase_number or "N/A"}
- Plan: {plan_number or "N/A"}
- Task: manual
- Phase directory: {phase_dir or ".planning/reviews"}
- Report path: {computed report path}
- Severity levels: critical (blocks), warning (recommended), info (informational)
- Two separate reports: spec compliance + code quality
- Spec findings MUST cite plan task or requirement (if plan context available)
- Architectural concerns are warning/info only, never critical
</review_rules>
```

Spawn via Task tool:
- `subagent_type`: `"general-purpose"`
- `description`: `"Manual code review: {scope description}"`

Wait for completion.

**Step 6: Display Results**
Parse the structured result (look for `## REVIEW COMPLETE`).

Display results in design system format:
```
+===============================================+
|  Review Complete                              |
+-----------------------------------------------+
|  Scope: {description of what was reviewed}    |
|  Status: {passed | issues_found}              |
|  Critical: {N}                                |
|  Warnings: {N}                                |
|  Info: {N}                                    |
+===============================================+
```

If findings exist, display them organized by severity:
- Critical findings first (with specific fix suggestions)
- Warning findings second
- Info findings last

Display Next Up block:
- If passed: "Code review passed. No issues found."
- If issues found: "Review the findings above. Fix critical issues before proceeding."

**2. Create `commands/review.md`** -- Autocomplete proxy matching the existing command file pattern:
```yaml
---
description: Two-stage code review (spec compliance + code quality)
---

Invoke the mz:review skill and follow it exactly as presented to you
```

**3. Create `commands/verify.md`** -- Autocomplete proxy:
```yaml
---
description: Verify phase deliverables match acceptance criteria
---

Invoke the mz:verify skill and follow it exactly as presented to you
```

**4. Update `skills/help/SKILL.md`**:
- Move /mz:review from "Coming soon" to "Available" with description: "Two-stage code review (spec + quality)"
- Move /mz:verify from "Coming soon" to "Available" with description: "Verify phase deliverables match criteria"
- Update the Available count (11 Available, 3 Coming soon)
- Add usage examples for the new commands:
  ```
  /mz:review          Review the latest commit
  /mz:review --plan 05-01  Review all changes from a plan
  /mz:review --last 3      Review last 3 commits
  /mz:verify           Verify current phase deliverables
  /mz:verify 5         Verify a specific phase
  /mz:verify --partial Verify even with incomplete plans
  ```
- Update the Phase line to: **Phase:** 5 of 8 (Code Review and Verification)
  </action>
  <verify>
1. skills/review/SKILL.md has `disable-model-invocation: false`, 6 steps, handles multiple scope modes (no args, --plan, --files, --last), spawns reviewer subagent, displays results
2. commands/review.md exists with correct frontmatter
3. commands/verify.md exists with correct frontmatter
4. skills/help/SKILL.md shows /mz:review and /mz:verify as Available (not Coming soon), 11 Available and 3 Coming soon
5. No npm/npx references in any new/modified file
6. skills/review/SKILL.md references agents/mz-reviewer.md and design-system.md
  </verify>
  <done>
The /mz:review skill provides on-demand two-stage code review with multiple scope options (latest commit, plan, specific files, last N commits). It works independently of the /mz:go pipeline and config settings. Both /mz:review and /mz:verify are listed as Available in help. Autocomplete proxies exist for both commands. The help listing is updated to reflect 11 available skills and 3 coming soon.
  </done>
</task>

</tasks>

<verification>
1. agents/mz-verifier.md exists with goal-backward verification, 3-level artifact checking, key link verification, requirements coverage, hybrid mode support (at least 120 lines)
2. skills/verify/SKILL.md is a full orchestrator (not a stub), disable-model-invocation: false, handles passed/gaps_found/human_needed, at least 150 lines
3. skills/verify/verifier.md exists with verification protocol documentation
4. skills/review/SKILL.md is a full standalone skill (not a stub), disable-model-invocation: false, supports multiple review scopes, at least 80 lines
5. commands/review.md and commands/verify.md exist as autocomplete proxies
6. skills/help/SKILL.md shows 11 Available skills and 3 Coming soon (debug, discuss, map)
7. No npm/npx references in any new/modified file
8. Verifier agent does NOT trust SUMMARY.md -- verifies against actual codebase
9. Review skill works independently of config.quality.review setting
</verification>

<success_criteria>
Running /mz:verify spawns a verifier subagent that performs goal-backward verification of phase deliverables against both ROADMAP.md success criteria and PLAN.md must_haves. The verifier checks truths, artifacts (3-level), key links, and requirement coverage against the actual codebase, producing VERIFICATION.md. Hybrid mode presents ambiguous items to the user. Running /mz:review provides on-demand two-stage code review at any time. Both skills are registered in help and have autocomplete proxies. This satisfies QUAL-06 (verification) and completes QUAL-01 (review skill availability).
</success_criteria>

<output>
After completion, create `.planning/phases/05-code-review-and-verification/05-02-SUMMARY.md`
</output>
