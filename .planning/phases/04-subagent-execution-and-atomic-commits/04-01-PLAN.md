---
phase: 04-subagent-execution-and-atomic-commits
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/plan.ts
  - src/cli/commands/plan-tools.ts
  - src/lib/state.ts
  - src/cli/commands/state.ts
  - src/cli/index.ts
autonomous: true
requirements: [PROJ-08, AGNT-02]

must_haves:
  truths:
    - "megazord tools plan list --phase-dir {dir} outputs JSON array of plan metadata from PLAN.md frontmatter"
    - "megazord tools plan waves --phase-dir {dir} groups plans into waves based on wave field"
    - "megazord tools plan incomplete --phase-dir {dir} returns only plans without matching SUMMARY.md"
    - "megazord tools plan conflicts --phase-dir {dir} detects file overlap between plans in the same wave"
    - "megazord tools state advance-plan increments plan counter and recalculates progress"
    - "megazord tools state record-metric appends execution timing to Performance Metrics"
    - "megazord tools state add-decision appends a decision to Accumulated Context"
  artifacts:
    - path: "src/lib/plan.ts"
      provides: "Plan parsing, wave computation, conflict detection, completion checking"
      min_lines: 80
    - path: "src/cli/commands/plan-tools.ts"
      provides: "CLI commands: list, waves, incomplete, conflicts"
      min_lines: 60
    - path: "src/lib/state.ts"
      provides: "Extended with advancePlan, recordMetric, addDecision functions"
      min_lines: 130
    - path: "src/cli/commands/state.ts"
      provides: "Extended with advance-plan, record-metric, add-decision CLI subcommands"
      min_lines: 80
  key_links:
    - from: "src/cli/commands/plan-tools.ts"
      to: "src/lib/plan.ts"
      via: "import plan parsing functions"
      pattern: "import.*from.*lib/plan"
    - from: "src/cli/commands/state.ts"
      to: "src/lib/state.ts"
      via: "import state management functions"
      pattern: "import.*advancePlan.*from.*lib/state"
    - from: "src/cli/index.ts"
      to: "src/cli/commands/plan-tools.ts"
      via: "register plan tools subcommand group"
      pattern: "registerPlanCommands"
---

<objective>
Create the TypeScript foundation for plan execution: a plan parsing library that reads PLAN.md frontmatter via gray-matter, computes wave execution order, detects file conflicts between parallel plans, and checks plan completion status. Extend the state management library with execution lifecycle commands (advance-plan, record-metric, add-decision). Expose all operations as CLI tools with JSON output for skill consumption.

Purpose: The /mz:go skill (Plan 02) needs programmatic access to plan metadata, wave ordering, and state updates. These CLI tools are the bridge between the Markdown skill orchestrator and the TypeScript logic.

Output: `src/lib/plan.ts`, `src/cli/commands/plan-tools.ts`, extended `src/lib/state.ts`, extended `src/cli/commands/state.ts`, updated `src/cli/index.ts`
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/state.ts
@src/cli/commands/state.ts
@src/cli/index.ts
@src/lib/config.ts
@src/cli/commands/progress.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plan parsing library and CLI commands</name>
  <files>
src/lib/plan.ts
src/cli/commands/plan-tools.ts
  </files>
  <action>
Create `src/lib/plan.ts` with plan parsing, wave computation, and conflict detection:

1. **Imports:** gray-matter (already installed), fs-extra (default import), path, zod.

2. **PlanMetadata schema (Zod):** Validate parsed frontmatter with these fields:
   - `phase`: z.string()
   - `plan`: z.union([z.string(), z.number()]).transform(v => String(v).padStart(2, "0"))
   - `type`: z.string().default("execute")
   - `wave`: z.number().default(1)
   - `depends_on`: z.array(z.string()).default([])
   - `files_modified`: z.array(z.string()).default([])
   - `autonomous`: z.boolean().default(true)
   - `requirements`: z.array(z.string()).default([])

3. **PlanFile interface:** `{ path: string; filename: string; metadata: PlanMetadata; content: string }`

4. **PlanWave interface:** `{ wave: number; plans: PlanFile[] }` (use PlanFile[], not PlanMetadata[], so the orchestrator has access to full content for embedding)

5. **Functions to export:**
   - `parsePlan(planPath: string): PlanFile` -- read file, parse with gray-matter, validate with Zod schema, return PlanFile with full content (including frontmatter, for embedding in Task prompts)
   - `listPlanFiles(phaseDir: string): PlanFile[]` -- read directory, filter files matching `/^\d+-\d+-PLAN\.md$/`, sort, parse each
   - `computeWaves(plans: PlanFile[]): PlanWave[]` -- group by wave field, sort by wave number, return array of PlanWave
   - `isPlanComplete(phaseDir: string, meta: PlanMetadata): boolean` -- check if `{padded}-{plan}-SUMMARY.md` exists. Extract padded from meta.phase by splitting on "-" and taking first segment.
   - `getIncompletePlans(phaseDir: string): PlanFile[]` -- filter listPlanFiles by !isPlanComplete
   - `detectWaveConflicts(plans: PlanFile[]): Map<string, string[]>` -- build fileOwners map from files_modified, return entries with 2+ owners. Owner ID format: `{padded}-{plan}` (e.g., "04-01")

Follow established patterns:
- Use `fse` as the default import for fs-extra (same as state.ts)
- Use Zod for validation (same as config.ts)
- All functions are synchronous (readFileSync) matching existing state.ts pattern

Create `src/cli/commands/plan-tools.ts` with CLI commands:

1. Export `registerPlanCommands(parent: Command): void`
2. Create a `plan` subcommand group under parent (same pattern as state/stash groups in state.ts)
3. Four commands, all producing JSON output:
   - `list --phase-dir <path>`: List all plans with metadata + completion status. Output: array of `{ filename, ...metadata, completed: boolean }`
   - `waves --phase-dir <path>`: Compute wave structure. Output: array of `{ wave: number, plans: [{ filename, phase, plan, depends_on, files_modified }] }`
   - `incomplete --phase-dir <path>`: List incomplete plans. Output: array of `{ filename, ...metadata }`
   - `conflicts --phase-dir <path>`: Detect file conflicts per wave. Output: `{ wave_N: { "file/path": ["04-01", "04-02"] } }` (only waves with conflicts)

All commands use `console.log(JSON.stringify(result, null, 2))` for output (established pattern from state.ts).
  </action>
  <verify>
Run `bun run build` -- build succeeds with no errors.
Run `bun run typecheck` -- type check passes.
Run `node bin/megazord.mjs tools plan --help` -- shows list, waves, incomplete, conflicts subcommands.
  </verify>
  <done>
src/lib/plan.ts exports parsePlan, listPlanFiles, computeWaves, isPlanComplete, getIncompletePlans, detectWaveConflicts. src/cli/commands/plan-tools.ts exports registerPlanCommands with 4 JSON-output CLI commands. Build and typecheck pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend state management with execution lifecycle commands</name>
  <files>
src/lib/state.ts
src/cli/commands/state.ts
src/cli/index.ts
  </files>
  <action>
Extend `src/lib/state.ts` with three new exported functions:

1. **`advancePlan(planningDir: string): { success: boolean; plan: number; totalPlans: number; isLast: boolean }`**
   - Read current position via readPosition()
   - Increment plan by 1
   - Determine if this is the last plan: `newPlan >= totalPlans`
   - Update position with new plan number and status (if last: "Phase complete", else keep current status)
   - Recalculate progress via calculateProgress() and update progressPercent
   - Return result object

2. **`recordMetric(planningDir: string, phase: string, plan: string, duration: string, tasks: number, files: number): void`**
   - Read STATE.md content
   - Find the "Performance Metrics" section
   - Find the "**By Phase:**" table within it
   - Check if a row for this phase already exists in the table
   - If phase row exists: update the values (increment plans count, add duration, recalculate average)
   - If phase row does not exist: append a new row `| {phase} | 1 | {duration} | {duration} |`
   - Also update the total plans completed count and total execution time in the "**Velocity:**" section
   - Use the existing extractSection/replaceSection pattern

3. **`addDecision(planningDir: string, phase: string, decision: string): void`**
   - Read STATE.md content
   - Find the "### Decisions" subsection within "## Accumulated Context"
   - Append `- Phase {phase}: {decision}` after the last existing decision line (before the next heading or blank line)
   - Use the existing section manipulation patterns
   - Handle the "Decisions are logged in PROJECT.md" header line -- append after all existing `- Phase ...` or `- Roadmap:` lines

Extend `src/cli/commands/state.ts` with three new subcommands under the `state` group:

1. **`advance-plan`**: No required options. Reads planningDir from `process.cwd()/.planning`. Calls advancePlan(), outputs JSON result.
2. **`record-metric --phase <string> --plan <string> --duration <string> --tasks <number> --files <number>`**: All required. Calls recordMetric(), outputs `{ success: true }`.
3. **`add-decision --phase <string> --decision <string>`**: Both required. Calls addDecision(), outputs `{ success: true }`.

All three follow the existing pattern: `const planningDir = \`${process.cwd()}/.planning\``.

Update `src/cli/index.ts`:
- Add dynamic import and registration of plan-tools: `const { registerPlanCommands } = await import("./commands/plan-tools.js");` followed by `registerPlanCommands(tools);`
- Place it alongside the existing registerStateCommands and registerProgressCommands calls
  </action>
  <verify>
Run `bun run build` -- build succeeds.
Run `bun run typecheck` -- type check passes.
Run `node bin/megazord.mjs tools state advance-plan --help` -- shows command.
Run `node bin/megazord.mjs tools state record-metric --help` -- shows --phase, --plan, --duration, --tasks, --files options.
Run `node bin/megazord.mjs tools state add-decision --help` -- shows --phase, --decision options.
Run `node bin/megazord.mjs tools plan list --help` -- shows --phase-dir option.
  </verify>
  <done>
state.ts exports advancePlan, recordMetric, addDecision. state CLI has advance-plan, record-metric, add-decision subcommands. plan CLI has list, waves, incomplete, conflicts subcommands. index.ts registers both plan-tools and updated state commands. Build and typecheck pass.
  </done>
</task>

</tasks>

<verification>
1. `bun run build` succeeds with zero errors
2. `bun run typecheck` passes
3. `node bin/megazord.mjs tools plan --help` shows plan subcommand group
4. `node bin/megazord.mjs tools state advance-plan --help` shows the command
5. All CLI commands produce valid JSON output
6. No regressions in existing CLI commands (install, uninstall, update, version, help, tools state, tools stash, tools progress)
</verification>

<success_criteria>
The TypeScript plan parsing library correctly reads PLAN.md frontmatter via gray-matter, computes wave order, detects file conflicts, and checks completion status. The state management library supports execution lifecycle operations (advancing plans, recording metrics, adding decisions). All operations are exposed as CLI tools with JSON output. The build pipeline compiles and type-checks without errors.
</success_criteria>

<output>
After completion, create `.planning/phases/04-subagent-execution-and-atomic-commits/04-01-SUMMARY.md`
</output>
