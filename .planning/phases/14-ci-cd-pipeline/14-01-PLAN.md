---
phase: 14-ci-cd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [.github/workflows/ci.yml, src/__tests__/smoke.test.ts]
autonomous: true
requirements: [CICD-01, CICD-03, DOCS-03]

must_haves:
  truths:
    - "A pull request to master triggers the CI workflow and runs typecheck, lint, and test"
    - "CI fails on any linter warning (zero tolerance via biome ci --error-on-warnings)"
    - "CI uses bun for all quality checks (typecheck, lint, test)"
    - "At least one test file exists so vitest does not exit with code 1"
    - "README CI badge auto-activates once ci.yml exists on the master branch"
  artifacts:
    - path: ".github/workflows/ci.yml"
      provides: "PR quality gate workflow"
      contains: "oven-sh/setup-bun@v2"
    - path: "src/__tests__/smoke.test.ts"
      provides: "Minimal smoke test so CI has something to run"
      contains: "describe"
  key_links:
    - from: ".github/workflows/ci.yml"
      to: "package.json scripts"
      via: "bun run typecheck, bunx biome ci, bun run test"
      pattern: "bun run (typecheck|test)"
    - from: "README.md badge"
      to: ".github/workflows/ci.yml"
      via: "GitHub Actions workflow status badge referencing ci.yml"
      pattern: "ci\\.yml"
---

<objective>
Create the GitHub Actions CI workflow that gates every pull request with typecheck, lint, and test checks, plus a minimal smoke test so the test step passes.

Purpose: Automated quality gate -- no PR can be merged without passing typecheck, lint (zero-tolerance), and tests. The README CI badge (already referencing ci.yml) will auto-activate.
Output: `.github/workflows/ci.yml` and `src/__tests__/smoke.test.ts`
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-ci-cd-pipeline/14-RESEARCH.md
@package.json
@biome.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CI workflow and smoke test</name>
  <files>.github/workflows/ci.yml, src/__tests__/smoke.test.ts</files>
  <action>
**1. Create `.github/workflows/ci.yml`:**

```yaml
name: CI

on:
  pull_request:
    branches: [master]
  push:
    branches: [master]

jobs:
  quality:
    name: Quality
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: oven-sh/setup-bun@v2

      - name: Install dependencies
        run: bun install --frozen-lockfile

      - name: Typecheck
        run: bun run typecheck

      - name: Lint
        run: bunx biome ci --error-on-warnings .

      - name: Test
        run: bun run test
```

Key details:
- Triggers on `pull_request` to `master` (quality gate) AND `push` to `master` (for status badge)
- Default branch is `master` (NOT `main`) — confirmed from git branch output
- Job name is `Quality` — this is the status check context for branch protection (Plan 02)
- Uses `oven-sh/setup-bun@v2` per locked decision (CICD-03)
- `bun install --frozen-lockfile` for reproducible installs
- `bunx biome ci --error-on-warnings .` — NOT `biome check`. `biome ci` is read-only CI mode with GitHub annotations. `--error-on-warnings` enforces zero-tolerance per locked decision
- `bun run test` (NOT `bun test`) — runs vitest via package.json script, not Bun's built-in runner

**2. Create `src/__tests__/smoke.test.ts`:**

A minimal smoke test that imports the main CLI module and verifies it exports expected symbols. This ensures:
- vitest has at least one test file (exits code 1 with zero files — Research pitfall 7)
- The TypeScript compiles and resolves correctly
- Basic module loading works

```typescript
import { describe, it, expect } from "vitest";

describe("smoke", () => {
  it("package.json has correct name", async () => {
    const pkg = await import("../../package.json", { with: { type: "json" } });
    expect(pkg.default.name).toBe("megazord-cli");
  });

  it("package.json has bin entry", async () => {
    const pkg = await import("../../package.json", { with: { type: "json" } });
    expect(pkg.default.bin).toHaveProperty("megazord");
  });
});
```

This is intentionally minimal — a smoke test, not a test suite. Future phases can add real unit tests.
  </action>
  <verify>
1. `ls .github/workflows/ci.yml` — file exists
2. `ls src/__tests__/smoke.test.ts` — file exists
3. `bun run test` — vitest finds and runs the smoke test, exits 0
4. `bun run typecheck` — no type errors in the new test file
5. `bunx biome ci --error-on-warnings .` — lint passes (no warnings)
  </verify>
  <done>
CI workflow file exists at `.github/workflows/ci.yml` targeting `master` branch with typecheck, lint (zero-tolerance), and test steps using bun. Smoke test exists and passes locally.
  </done>
</task>

</tasks>

<verification>
1. `.github/workflows/ci.yml` exists with correct YAML structure
2. Workflow triggers on `pull_request` to `master` and `push` to `master`
3. Workflow uses `oven-sh/setup-bun@v2` (not setup-node for build/test)
4. Lint step uses `bunx biome ci --error-on-warnings .` (not `biome check`)
5. Test step uses `bun run test` (not `bun test`)
6. `src/__tests__/smoke.test.ts` exists and `bun run test` passes
7. All three quality checks pass locally: typecheck, lint, test
</verification>

<success_criteria>
- CI workflow file is syntactically valid YAML
- Smoke test passes with `bun run test`
- Typecheck passes with the new test file included
- Lint passes with zero warnings on the test file
- README CI badge URL (already exists) references `ci.yml` and `branch=master`
</success_criteria>

<output>
After completion, create `.planning/phases/14-ci-cd-pipeline/14-01-SUMMARY.md`
</output>
