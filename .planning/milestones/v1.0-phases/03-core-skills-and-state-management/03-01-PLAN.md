---
phase: 03-core-skills-and-state-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/state.ts
  - src/cli/commands/state.ts
  - src/cli/commands/progress.ts
  - src/cli/index.ts
autonomous: true
requirements: [PROJ-04, PROJ-05, PROJ-06, PROJ-11]

must_haves:
  truths:
    - "Running `megazord tools state read-position` outputs current phase, plan, status, and progress from STATE.md"
    - "Running `megazord tools state update-session` updates Session Continuity fields (stash ref, last error, stopped at) in STATE.md"
    - "Running `megazord tools stash pause` stashes modified files with mz:pause message and outputs the stash ref as JSON"
    - "Running `megazord tools stash resume` pops the specified stash ref and handles conflicts gracefully"
    - "Running `megazord tools progress` calculates overall and within-phase progress from ROADMAP.md and phase directories"
  artifacts:
    - path: "src/lib/state.ts"
      provides: "STATE.md parsing, updating, progress calculation, git stash management"
      min_lines: 100
    - path: "src/cli/commands/state.ts"
      provides: "CLI subcommands for state read/write operations"
      exports: ["registerStateCommands"]
    - path: "src/cli/commands/progress.ts"
      provides: "CLI subcommands for progress calculation"
      exports: ["registerProgressCommands"]
    - path: "src/cli/index.ts"
      provides: "Extended CLI with tools subcommand group"
      contains: "tools"
  key_links:
    - from: "src/cli/commands/state.ts"
      to: "src/lib/state.ts"
      via: "import"
      pattern: "import.*from.*state"
    - from: "src/cli/commands/progress.ts"
      to: "src/lib/state.ts"
      via: "import"
      pattern: "import.*from.*state"
    - from: "src/cli/index.ts"
      to: "src/cli/commands/state.ts"
      via: "dynamic import"
      pattern: "import.*commands/state"
---

<objective>
Build the TypeScript state management layer and CLI tooling that all Phase 3 skills depend on.

Purpose: Skills (SKILL.md) need reliable TypeScript helpers for operations Markdown cannot do safely -- parsing STATE.md sections, updating structured fields, managing git stash, and calculating progress. These helpers are exposed as CLI subcommands that skills invoke via Bash.

Output: src/lib/state.ts (core library), src/cli/commands/state.ts and progress.ts (CLI wrappers), updated src/cli/index.ts (tools subcommand group).
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-core-skills-and-state-management/03-RESEARCH.md
@src/lib/config.ts
@src/lib/paths.ts
@src/cli/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state management library (src/lib/state.ts)</name>
  <files>src/lib/state.ts</files>
  <action>
Create `src/lib/state.ts` with the following exports:

**Interfaces:**
- `StatePosition`: phase (number), totalPhases (number), phaseName (string), plan (number), totalPlans (number), status (string), lastActivity (string), progressPercent (number)
- `SessionContinuity`: lastSession (string), stoppedAt (string), resumeFile (string), stashRef (string | null), lastError (string | null)
- `StashResult`: success (boolean), stashRef (string | null), message (string)

**STATE.md parsing/updating functions:**
- `readPosition(planningDir: string): StatePosition | null` -- parse `## Current Position` section from STATE.md. Extract fields using line-by-line parsing (not regex on whole file). Return null if STATE.md doesn't exist.
- `readSessionContinuity(planningDir: string): SessionContinuity | null` -- parse `## Session Continuity` section. Handle both existing 3-field format (last session, stopped at, resume file) and new 5-field format (+ stash ref, last error).
- `updatePosition(planningDir: string, updates: Partial<StatePosition>): void` -- read STATE.md, find `## Current Position` section, update only the changed fields, write back. Use Edit-style targeted replacement (read full file, replace section, write back). Preserve all other sections.
- `updateSessionContinuity(planningDir: string, updates: Partial<SessionContinuity>): void` -- update `## Session Continuity` section. Add `Stash ref:` and `Last error:` lines if they don't exist. Update values if they do.
- `progressBar(percent: number): string` -- return 20-char Unicode block progress bar: `[████████░░░░░░░░░░░░] 40%`. Use `\u2588` (full block) for filled, `\u2591` (light shade) for empty.

**Git stash functions (from research code examples):**
- `stashPause(description: string): StashResult` -- check `git status --porcelain` for changes. If none, return success with null stashRef and "No modified files to stash" message. If changes exist, run `git stash push -m "mz:pause -- {description}"`, verify stash count increased, capture stash ref from `git stash list --format="%gd" -1`. Handle errors with try/catch.
- `stashResume(stashRef: string): StashResult` -- verify stash exists in `git stash list`. If not found, return failure with "Stash {ref} not found" message. Attempt `git stash pop {stashRef}`. On CONFLICT, return failure with resolution instructions. On success, return success with null stashRef.

**Progress calculation:**
- `calculateProgress(planningDir: string): { overall: number, currentPhase: { completed: number, total: number } }` -- read ROADMAP.md, count phases (lines matching `- [ ] **Phase` or `- [x] **Phase`). Count completed phases. For current phase, count PLAN.md and SUMMARY.md files to determine plan completion. Calculate overall: `(completedPhases + currentPhasePlanProgress/totalPlansInPhase) / totalPhases * 100`. Round to nearest integer.

Use `fs-extra` (default import) for file operations. Use `execSync` from `child_process` for git commands. Follow the same import style as `src/lib/config.ts` (default import for fs-extra).
  </action>
  <verify>
Run `bun run build` to verify TypeScript compiles. Run `bun test src/lib/state.ts` if test exists. Verify the file exports all listed functions by checking with `grep -c "export function" src/lib/state.ts` (should be >= 7).
  </verify>
  <done>
src/lib/state.ts exists with all 7+ exported functions. TypeScript compiles without errors. Functions handle all documented edge cases (missing STATE.md, no stash changes, stash conflicts, empty ROADMAP).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CLI commands and register tools subgroup</name>
  <files>
src/cli/commands/state.ts
src/cli/commands/progress.ts
src/cli/index.ts
  </files>
  <action>
**Create `src/cli/commands/state.ts`:**

Export a `registerStateCommands(parent: Command): void` function that adds subcommands to a parent commander Command:

- `state read-position` -- calls `readPosition(process.cwd() + '/.planning')`, outputs JSON to stdout. Exit 0 if found, exit 1 if STATE.md missing.
- `state read-session` -- calls `readSessionContinuity(...)`, outputs JSON.
- `state update-position --phase N --plan N --status STR --progress N` -- calls `updatePosition(...)` with provided fields. Only updates fields that are passed.
- `state update-session --stopped-at STR --resume-file STR --stash-ref STR --last-error STR` -- calls `updateSessionContinuity(...)`.
- `stash pause --description STR` -- calls `stashPause(description)`, outputs JSON result.
- `stash resume --stash-ref STR` -- calls `stashResume(stashRef)`, outputs JSON result.

Import from `../lib/state.js` (note .js extension for ESM).

**Create `src/cli/commands/progress.ts`:**

Export a `registerProgressCommands(parent: Command): void` function:

- `progress` -- calls `calculateProgress(process.cwd() + '/.planning')`, outputs JSON with `{ overall, currentPhase: { completed, total }, bar }` where `bar` is the progress bar string.

Import `calculateProgress` and `progressBar` from `../lib/state.js`.

**Modify `src/cli/index.ts`:**

Add a `tools` subcommand group after the existing install/uninstall/version/help commands:

```typescript
const tools = program.command("tools").description("Internal tools for Megazord skills");

// Register subcommands
const { registerStateCommands } = await import("./commands/state.js");
const { registerProgressCommands } = await import("./commands/progress.js");
registerStateCommands(tools);
registerProgressCommands(tools);
```

Use dynamic imports (matching existing pattern for install/uninstall). The `tools` group should be non-interactive (JSON output, no spinners, no colors) since skills parse the output.

All JSON output uses `JSON.stringify(result, null, 2)` for readability during debugging.
  </action>
  <verify>
Run `bun run build`. Then test CLI commands:
- `node bin/megazord.mjs tools --help` should show state, stash, progress subcommands
- `node bin/megazord.mjs tools progress` should output JSON (may show defaults or error if no .planning/)
- `node bin/megazord.mjs tools state read-position` should output JSON or exit 1
  </verify>
  <done>
`megazord tools state`, `megazord tools stash`, and `megazord tools progress` subcommands are registered and callable. Build passes. JSON output is parseable by skills via Bash.
  </done>
</task>

</tasks>

<verification>
1. `bun run build` succeeds without errors
2. `node bin/megazord.mjs tools --help` shows tools subcommand group
3. `node bin/megazord.mjs tools state read-position` produces JSON (or appropriate error)
4. `node bin/megazord.mjs tools stash pause --description "test"` produces JSON result
5. `node bin/megazord.mjs tools progress` produces JSON with overall percentage
6. No changes to existing install/uninstall functionality
</verification>

<success_criteria>
TypeScript state management library exists with STATE.md parsing, session continuity management, git stash helpers, and progress calculation. CLI exposes these as `megazord tools` subcommands that skills can call via Bash. Build produces working bin/megazord.mjs. All existing CLI functionality (install, uninstall, version, help) still works.
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-skills-and-state-management/03-01-SUMMARY.md`
</output>
