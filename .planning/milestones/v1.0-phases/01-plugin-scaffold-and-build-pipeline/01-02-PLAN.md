---
phase: 01-plugin-scaffold-and-build-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/cli/index.ts
  - src/cli/commands/install.ts
  - src/cli/commands/uninstall.ts
  - src/cli/utils/detect-plugins.ts
  - src/cli/utils/spinner.ts
  - src/cli/utils/colors.ts
  - src/lib/paths.ts
  - bin/megazord.mjs
autonomous: true
requirements:
  - DIST-03
  - DIST-04
  - DIST-05
  - PROJ-12

must_haves:
  truths:
    - "Running `bunx megazord` starts the interactive installer"
    - "Running `megazord --version` prints 0.1.0"
    - "Running `megazord help` shows all available CLI commands"
    - "The installer detects existing GSD and Superpowers installations"
    - "The installer creates a local marketplace and registers the plugin via claude plugin install"
    - "TypeScript source compiles to a single bin/megazord.mjs via tsdown"
    - "Framework overhead with all skills registered stays under 15% of context window"
  artifacts:
    - path: "src/cli/index.ts"
      provides: "CLI entry point with Commander.js routing"
      exports: ["default command (install)", "install", "uninstall", "version"]
      min_lines: 30
    - path: "src/cli/commands/install.ts"
      provides: "Interactive plugin installation logic"
      exports: ["install"]
      min_lines: 50
    - path: "src/cli/commands/uninstall.ts"
      provides: "Plugin removal logic"
      exports: ["uninstall"]
      min_lines: 20
    - path: "src/cli/utils/detect-plugins.ts"
      provides: "Detection of Claude Code, GSD, Superpowers, and Megazord installations"
      exports: ["detectPlugins"]
      min_lines: 30
    - path: "src/cli/utils/spinner.ts"
      provides: "Ora spinner wrapper with project styling"
      exports: ["createSpinner"]
      min_lines: 10
    - path: "src/cli/utils/colors.ts"
      provides: "Picocolors wrapper with project palette"
      exports: ["success", "error", "warn", "info"]
      min_lines: 10
    - path: "src/lib/paths.ts"
      provides: "Path resolution for Claude, plugin, and project directories"
      exports: ["claudeDir", "pluginsDir", "settingsPath", "resolvePluginPath"]
      min_lines: 15
    - path: "bin/megazord.mjs"
      provides: "Compiled CLI entry point"
      contains: "#!/usr/bin/env node"
  key_links:
    - from: "src/cli/index.ts"
      to: "src/cli/commands/install.ts"
      via: "dynamic import"
      pattern: 'import.*commands/install'
    - from: "src/cli/commands/install.ts"
      to: "src/cli/utils/detect-plugins.ts"
      via: "import detectPlugins"
      pattern: "detectPlugins"
    - from: "src/cli/commands/install.ts"
      to: "src/lib/paths.ts"
      via: "import path helpers"
      pattern: "claudeDir|pluginsDir"
    - from: "tsdown.config.ts"
      to: "bin/megazord.mjs"
      via: "tsdown build"
      pattern: 'outDir.*"bin"'
    - from: "package.json"
      to: "bin/megazord.mjs"
      via: "bin field"
      pattern: '"megazord".*bin/megazord.mjs'
---

<objective>
Build the TypeScript CLI (`mz-tools`), compile it with tsdown, and verify the full plugin works: installation flow, coexistence with existing plugins, and context budget compliance.

Purpose: Make `bunx megazord` a working command that installs the Megazord plugin into Claude Code, detects existing frameworks, and produces a functional plugin that meets the 15% context budget target.

Output: Compiled CLI at bin/megazord.mjs, all TypeScript source in src/, verified build pipeline, coexistence confirmed, context budget measured.
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-plugin-scaffold-and-build-pipeline/01-RESEARCH.md
@.planning/phases/01-plugin-scaffold-and-build-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript CLI source with install, uninstall, and utilities</name>
  <files>
    src/cli/index.ts
    src/cli/commands/install.ts
    src/cli/commands/uninstall.ts
    src/cli/utils/detect-plugins.ts
    src/cli/utils/spinner.ts
    src/cli/utils/colors.ts
    src/lib/paths.ts
  </files>
  <action>
Create all TypeScript source files for the Megazord CLI.

**src/lib/paths.ts** — Path resolution utilities:
- `claudeDir`: resolves `~/.claude/`
- `pluginsDir`: resolves `~/.claude/plugins/`
- `pluginsCacheDir`: resolves `~/.claude/plugins/cache/`
- `settingsPath`: resolves `~/.claude/settings.json`
- `installedPluginsPath`: resolves `~/.claude/plugins/installed_plugins.json`
- `gsdCommandsDir`: resolves `~/.claude/commands/gsd/`
- `marketplacesDir`: resolves `~/.claude/marketplaces/`
- `resolvePluginPath(name: string)`: resolves plugin directory in cache
- All paths use `path.join(homedir(), '.claude', ...)` — never hardcode home directory

**src/cli/utils/colors.ts** — Picocolors wrapper:
- Export named color functions: `success` (green), `error` (red), `warn` (yellow), `info` (cyan), `dim` (gray), `bold` (bold)
- Each is a thin wrapper: `export const success = (msg: string) => pc.green(msg)`
- Per user decision: friendly and informative tone, colors for status indicators

**src/cli/utils/spinner.ts** — Ora spinner wrapper:
- `createSpinner(text: string)` — creates ora spinner with default options
- `spinnerSuccess(spinner, text)` — stops with green success symbol
- `spinnerFail(spinner, text)` — stops with red fail symbol
- Per user decision: minimal feedback with spinner, short messages ("Installing...", "Done!")

**src/cli/utils/detect-plugins.ts** — Plugin detection:
- `detectPlugins()` returns `PluginDetectionResult` with: `claudeCodeInstalled`, `gsdInstalled`, `superpowersInstalled`, `megazordInstalled`, `existingPlugins[]`
- Check Claude Code: `existsSync(claudeDir)`
- Check GSD: `existsSync(gsdCommandsDir)`
- Check Superpowers: parse `settings.json` → `enabledPlugins` containing "superpowers"
- Check Megazord: parse `installed_plugins.json` → plugins key starting with "mz@"
- All checks wrapped in try/catch — corrupted files don't crash detection
- Use the exact implementation pattern from the research code example

**src/cli/commands/install.ts** — Main installer:
- Use helpers from `src/lib/paths.ts` (`claudeDir`, `pluginsDir`, `marketplacesDir`, `gsdCommandsDir`, `settingsPath`, `installedPluginsPath`) rather than constructing paths inline. All path construction MUST go through paths.ts.
- Export async `install()` function
- Flow:
  1. Print banner: "Megazord v{version}" with moderate emoji (one rocket or lightning bolt)
  2. Detect environment via `detectPlugins()`
  3. If Claude Code not installed → error with suggested action ("Is Claude Code installed? Run `claude --version` to check.")
  4. If Megazord already installed → prompt: Update / Reinstall / Uninstall / Cancel
  5. If GSD detected → info message: "GSD detected — Megazord coexists peacefully. Both /gsd: and /mz: commands will work."
  6. If Superpowers detected → info message: "Superpowers detected — Megazord coexists peacefully. Both /superpowers: and /mz: commands will work."
  7. Confirm installation with user (unless `--yes` flag)
  8. Create local marketplace: `~/.claude/marketplaces/megazord/marketplace.json` with content `{"name":"megazord-marketplace","description":"Megazord plugin marketplace","plugins":{"mz":{"source":{"source":"npm","package":"megazord"}}}}`
  9. Run `claude plugin install mz@megazord-marketplace` via child_process.execSync
  10. If claude plugin install fails → fallback: copy plugin files to `~/.claude/plugins/cache/megazord/mz/0.1.0/` and register in installed_plugins.json
  11. Verify installation: check plugin appears in installed_plugins.json
  12. Print success: "Megazord installed! Run /mz:help to get started."
- Support `--yes` flag for non-interactive installation (detect `!process.stdin.isTTY` as fallback)
- Per user decision: minimal spinner, short messages, friendly tone, emojis in moderation

**src/cli/commands/uninstall.ts** — Plugin removal:
- Export async `uninstall()` function
- Confirm with user before removing
- Run `claude plugin uninstall mz` if available
- Remove marketplace directory `~/.claude/marketplaces/megazord/`
- Print success message

**src/cli/index.ts** — CLI entry point:
- Import Commander.js, create program with name "megazord", description, version from package.json
- Register subcommands: install, uninstall, version
- Default action (no subcommand) = install
- Use dynamic imports for commands to keep startup fast: `const { install } = await import("./commands/install.js")`
- `program.parse()`
- NOTE: Import version from package.json using `import { createRequire } from "module"` or read package.json with `readFileSync` — don't use `import pkg from "../../package.json"` as it may not work with all bundler configs

Per user decision on CLI output style: friendly and informative like Vercel CLI, emoji with moderation, colors for status.
  </action>
  <verify>
- `bun run typecheck` passes (no TypeScript errors)
- All 7 source files exist with correct exports
- `grep "detectPlugins" src/cli/commands/install.ts` confirms import
- `grep "claudeDir" src/lib/paths.ts` confirms path helper
- No hardcoded home directory paths (no `/Users/` or `/home/` literals in source)
  </verify>
  <done>
All 7 TypeScript source files exist with correct implementations. CLI entry point routes to install/uninstall/version. Install command detects plugins, creates marketplace, runs claude plugin install with fallback. All paths use homedir() resolution. Type checking passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build pipeline — install dependencies, compile CLI, verify execution</name>
  <files>
    bin/megazord.mjs
  </files>
  <action>
Install dependencies and compile the CLI.

**Step 1: Install dependencies**
- Run `bun install` in project root
- Verify node_modules/ created and all dependencies resolved

**Step 2: Compile with tsdown**
- Run `bun run build` (which runs `tsdown`)
- Verify `bin/megazord.mjs` is created
- Verify the file starts with `#!/usr/bin/env node`
- Make executable: `chmod +x bin/megazord.mjs`

**Step 3: Verify CLI execution**
- Run `node bin/megazord.mjs --version` — should print "0.1.0"
- Run `node bin/megazord.mjs help` — should show install/uninstall/version commands
- Run `node bin/megazord.mjs --help` — should show full usage

**Step 4: Verify bunx simulation**
- Run `bun run bin/megazord.mjs --version` — should print "0.1.0"
- Note: Full `bunx megazord` test requires npm publish, which is deferred. `node bin/megazord.mjs` is the pre-publish equivalent.

**Step 5: Verify detect-plugins works on this machine**
- Create a simple test: run `node -e "import('./bin/megazord.mjs')"` or invoke the detection function directly
- Confirm it detects GSD (should be installed at ~/.claude/commands/gsd/) and Superpowers (should be in settings.json)

**If tsdown fails:** Check tsdown.config.ts external list matches actual imports. Common issue: missing an external dependency causes bundling failures. Also verify all import paths use `.js` extensions for ESM compatibility.

**If typecheck fails:** Fix any TypeScript errors before proceeding. Common issues: missing type imports for fs-extra, missing `@types/node`.

Add `.gitignore` entries if not already present: `node_modules/`, `dist/`, `bin/` (bin/ is a build artifact, committed only for distribution verification).
  </action>
  <verify>
- `bin/megazord.mjs` exists and is executable
- `node bin/megazord.mjs --version` outputs "0.1.0"
- `node bin/megazord.mjs help` shows available commands
- `bun run typecheck` passes
- `bun run build` completes without errors
  </verify>
  <done>
CLI compiles to bin/megazord.mjs via tsdown. Running `node bin/megazord.mjs --version` prints "0.1.0". Running `node bin/megazord.mjs help` shows install, uninstall, and version commands. TypeScript type checking passes. Build is reproducible.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify coexistence and measure context budget</name>
  <files></files>
  <action>
Verify the complete plugin against Phase 1 success criteria. This task modifies no files — it validates what Plan 01 and Tasks 1-2 built.

**Coexistence Verification (DIST-04):**
1. Check GSD is installed: `ls ~/.claude/commands/gsd/` — should show GSD commands
2. Check Superpowers is installed: `grep "superpowers" ~/.claude/settings.json` — should show enabled
3. Verify no file conflicts: Megazord lives in `.claude-plugin/` + `skills/` within the project repo. GSD lives in `~/.claude/commands/gsd/`. Superpowers lives in `~/.claude/plugins/cache/`. No overlapping paths.
4. Verify no namespace conflicts: Megazord uses `mz:` prefix. GSD uses `gsd:` prefix. Superpowers uses `superpowers:` prefix. All distinct.
5. List all plugin names and confirm uniqueness

**Context Budget Measurement (PROJ-12):**
1. Count total skill description characters across all 13 SKILL.md files:
   - `grep "^description:" skills/*/SKILL.md` to extract all descriptions
   - Sum character counts — should be approximately 1,800-2,000 chars
2. Calculate percentage of context budget:
   - Claude Code uses 2% of context window for skill descriptions
   - For Opus 4.6 with ~1M token context, 2% = ~20,000 tokens worth of chars
   - Megazord's ~2,000 chars is roughly 10% of the skill description budget
   - Overall framework overhead: skill descriptions only (no SessionStart hook, no agents yet)
3. Verify hooks/hooks.json has no SessionStart entries
4. Verify no agents/ directory exists (or if created, it's empty)
5. Document measured values in verification output

**Plugin Structure Verification (DIST-01):**
1. Confirm `.claude-plugin/plugin.json` has `"name": "mz"`
2. Confirm skills/ has exactly 13 subdirectories
3. Confirm each SKILL.md has valid YAML frontmatter (name, description, disable-model-invocation)
4. Confirm hooks/hooks.json exists and has empty hooks array

If any verification fails, document the failure and what needs fixing. Do NOT silently skip failures.
  </action>
  <verify>
- All coexistence checks pass (3 distinct namespaces, no path conflicts)
- Total skill description characters are under 3,000
- hooks.json has zero entries
- Plugin structure matches Claude Code conventions
- Context budget overhead is documented with measured numbers
  </verify>
  <done>
Coexistence verified: Megazord (mz:), GSD (gsd:), and Superpowers (superpowers:) use distinct namespaces with no path conflicts. Context budget measured: total skill description text is under 3,000 characters for 13 skill descriptions, well under 15% of context window. No SessionStart injection. Plugin structure matches Claude Code conventions.
  </done>
</task>

</tasks>

<verification>
1. **DIST-03 (npm distribution):** `bunx megazord` equivalent (`node bin/megazord.mjs`) runs the interactive installer. CLI routes to install/uninstall/version commands. Full `bunx megazord` test deferred to npm publish.

2. **DIST-05 (TypeScript CLI):** `mz-tools` TypeScript source compiles via tsdown to `bin/megazord.mjs`. Commander.js routes subcommands. `--version` and `help` work.

3. **PROJ-12 (context budget):** Measured skill description overhead is under 15% of context window. No SessionStart hooks inject content. Only `/mz:help` is model-invocable.

4. **End-to-end:** Plugin manifest + skill stubs (Plan 01) + compiled CLI (this plan) = complete Phase 1 deliverable.
</verification>

<success_criteria>
- `node bin/megazord.mjs --version` prints "0.1.0"
- `node bin/megazord.mjs help` shows install/uninstall/version
- `bun run build` completes without errors
- `bun run typecheck` passes
- Coexistence verified with GSD and Superpowers
- Context budget measured and documented under 15%
</success_criteria>

<output>
After completion, create `.planning/phases/01-plugin-scaffold-and-build-pipeline/01-02-SUMMARY.md`
</output>
