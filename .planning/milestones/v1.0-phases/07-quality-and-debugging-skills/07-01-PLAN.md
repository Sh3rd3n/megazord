---
phase: 07-quality-and-debugging-skills
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - agents/mz-executor.md
  - skills/go/SKILL.md
  - skills/go/executor.md
autonomous: true
requirements:
  - QUAL-02
  - CRTX-01
  - CRTX-02
  - CRTX-03
  - CRTX-04
  - CRTX-05

must_haves:
  truths:
    - "When TDD is enabled, the executor follows RED-GREEN-REFACTOR per task with stage banners and violation detection"
    - "Every task is classified (Clear/Complicated/Complex/Chaotic) before execution when CORTEX is enabled"
    - "Challenge blocks (FAIL/ASSUME/COUNTER/VERDICT) appear before implementation on Complicated+ tasks"
    - "Anti-sycophancy rules prevent performative agreement -- only evidence-based evaluation"
    - "Pushback intensity scales with CORTEX level: Clear accepts, Complicated notes concerns, Complex/Chaotic actively challenges"
    - "Verification gate (IDENTIFY-RUN-READ-VERIFY-CLAIM) blocks premature completion claims"
  artifacts:
    - path: "agents/mz-executor.md"
      provides: "TDD protocol, CORTEX classification, challenge blocks, anti-sycophancy, pushback mandate, verification gate"
      contains: "## TDD Protocol"
    - path: "skills/go/SKILL.md"
      provides: "Config forwarding for TDD and CORTEX flags to executor"
      contains: "tdd_enabled"
    - path: "skills/go/executor.md"
      provides: "Updated execution protocol referencing TDD and CORTEX behavior"
      contains: "TDD"
  key_links:
    - from: "skills/go/SKILL.md"
      to: "agents/mz-executor.md"
      via: "execution_rules forwarding tdd_enabled and cortex_enabled flags"
      pattern: "tdd_enabled.*cortex_enabled"
    - from: "agents/mz-executor.md"
      to: "Commit Protocol"
      via: "TDD override allowing 2-3 commits per task in TDD mode"
      pattern: "RED.*GREEN.*REFACTOR"
---

<objective>
Add TDD enforcement, CORTEX adaptive classification, anti-sycophancy rules, pushback mandate, and verification gate to the executor agent. Extend the /mz:go orchestrator to forward TDD and CORTEX configuration flags to executors.

Purpose: The executor is the core agent that implements every task. Adding quality behaviors directly into its definition ensures TDD discipline, adaptive complexity handling, and honest evaluation happen automatically during execution -- not as afterthoughts.

Output: Modified `agents/mz-executor.md` with 5 new protocol sections. Modified `skills/go/SKILL.md` and `skills/go/executor.md` with config forwarding for quality flags.
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@agents/mz-executor.md
@skills/go/SKILL.md
@skills/go/executor.md
@.planning/phases/07-quality-and-debugging-skills/07-CONTEXT.md
@.planning/phases/07-quality-and-debugging-skills/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add TDD protocol, CORTEX classification, challenge blocks, anti-sycophancy, pushback mandate, and verification gate to executor agent</name>
  <files>agents/mz-executor.md</files>
  <action>
Modify `agents/mz-executor.md` to add the following sections BEFORE the existing "## Teammate Mode Protocol" section (so they apply to both subagent and teammate modes). All new sections are additive -- do NOT remove or alter any existing content.

**Section 1: TDD Protocol** (insert after "## Review Protocol" section, before "## Summary Creation")

Add a `## TDD Protocol` section with these subsections:

1. **Activation check:** "When `tdd_enabled` is `true` in `<execution_rules>`, follow RED-GREEN-REFACTOR for each task."

2. **Task Type Detection (auto-exemption per user decision):**
   - If ALL files in `<files>` are non-code (.md, .json, .yaml, .yml, .toml, .env, .sh, .css) â†’ EXEMPT, display: `TDD: Exempt (config/docs only)`
   - If task description contains only refactoring AND existing tests cover affected code â†’ EXEMPT, display: `TDD: Exempt (refactor with existing coverage)`
   - Otherwise â†’ TDD REQUIRED

3. **RED Stage:**
   - Display banner: `ðŸŸ¥ RED: Writing failing test for {task name}`
   - Analyze task's `<action>` and `<done>` criteria
   - Write test(s) that validate expected behavior
   - Run: `bun test` (or project's test command)
   - Confirm new test(s) FAIL (if passes: test doesn't validate new behavior, revise)
   - Commit test files only: `test({phase}-{plan}): RED -- {test description}`

4. **GREEN Stage:**
   - Display banner: `ðŸŸ© GREEN: Making test pass for {task name}`
   - Write MINIMUM implementation to pass the failing test
   - Run: `bun test`
   - If still fails: debug and fix, stay in GREEN until pass
   - Commit implementation files: `feat({phase}-{plan}): GREEN -- {implementation description}`

5. **REFACTOR Stage:**
   - Display banner: `ðŸ”µ REFACTOR: Cleaning up {task name}`
   - Review implementation for cleanup opportunities
   - Refactor while keeping ALL tests passing
   - Run: `bun test` after each change
   - If minimal: amend GREEN commit (`git commit --amend --no-edit`)
   - If substantial: separate commit: `refactor({phase}-{plan}): REFACTOR -- {cleanup description}`

6. **TDD + Review Integration:**
   - Review runs after GREEN commit (not after RED)
   - If review finds critical issues: fix and amend GREEN commit
   - RED commit is never amended (test spec is stable)

7. **TDD Commit Override:**
   - When TDD is active, the "One commit per task, no exceptions" rule is OVERRIDDEN
   - TDD produces 2-3 commits per task: RED (test), GREEN (implementation), optional REFACTOR
   - This is a documented exception to the Phase 4 one-commit rule

8. **Violation Detection (Claude's discretion on severity):**
   - MINOR (1-5 lines of impl before test): Revert impl lines, write test first, re-implement. Log as deviation.
   - STRUCTURAL (entire function/module without tests): STOP. Display warning: "TDD VIOLATION: {N} lines written before tests. Options: (a) revert and restart with TDD, (b) accept and write tests after (degraded TDD), (c) exempt this task." Escalate to user.

**Section 2: CORTEX Classification** (insert after TDD Protocol)

Add a `## CORTEX Classification` section:

1. **Activation check:** "When `cortex_enabled` is `true` in `<execution_rules>`, classify each task before execution."

2. **Classification (before every task):**
   Signals table:
   | Domain | Signals |
   |--------|---------|
   | Clear | Obvious solution, best practice exists, low risk |
   | Complicated | Multiple valid approaches, needs analysis, medium risk |
   | Complex | High uncertainty, emergent design, large scope, many unknowns |
   | Chaotic | Nothing works, external failures, crisis state |

   Output exactly one line: `CORTEX: {level} -- {brief signal}`

3. **Post-Classification Protocol:**
   - **Clear:** Execute directly. No challenge block.
   - **Complicated:** Output challenge block, then execute (or modify/reject per verdict).
   - **Complex:** Output challenge block + mini-brainstorm (2-3 alternatives, brief inline), select approach, proceed autonomously.
   - **Chaotic:** STOP. Display: `CORTEX: Chaotic -- {description}. Requesting user input.` Wait for user.

4. **Challenge Block Format:**
   ```
   <challenge>
   FAIL: [3 specific failure modes]
   ASSUME: [assumptions -- mark verified/unverified]
   COUNTER: [strongest argument against this approach]
   VERDICT: proceed | modify | reject
   </challenge>
   ```
   Rules:
   - FAIL: exactly 3 items, specific not vague
   - ASSUME: distinguish verified (checked) from unverified (guessed)
   - COUNTER: genuine attack, not a softball
   - VERDICT: honest assessment
   - If modify: state changes, then implement modified version
   - If reject: explain why, propose alternative, wait for plan

**Section 3: Pushback Mandate** (insert after CORTEX Classification)

Add a `## Pushback Mandate` section:

1. **Scope:** Pushback applies to NEW decisions and design choices the executor makes. It does NOT apply to plan-specified implementations (those were decided at planning time).

2. **Intensity scales with CORTEX level:**
   - Clear: Accept the approach. No pushback needed.
   - Complicated: Note concerns if any. "This works, but note: {concern}."
   - Complex/Chaotic: Actively challenge. "This approach has a problem: {evidence}. Alternative: {proposal}."

3. **Tone:** Direct and technical. Never "I think this might be bad." Always "This causes X because Y."

4. **Pushback protocol (when user overrides executor's recommendation):**
   - First pushback: Present concern with evidence and alternative.
   - Second pushback: Push back with DIFFERENT evidence (not repeating the first).
   - After second rejection: Accept and proceed. Log the disagreement as a decision in SUMMARY.md.

5. **Self-challenge (Claude's discretion):** Challenge own generated approaches when making non-trivial architectural choices not specified in the plan. If the plan specifies the approach, implement it without self-challenge.

**Section 4: Anti-Sycophancy** (insert after Pushback Mandate)

Add a `## Anti-Sycophancy` section:

1. **Banned responses:**
   - "Great idea!", "You're absolutely right!", "That's a great approach!"
   - "Sure, I'll do that!" (without evaluation)
   - Any agreement without evidence
   - "should work", "probably fine", "seems correct" (without verification)

2. **Required response patterns:**
   - Agreement: "That works because {reason}" (evidence-based)
   - Disagreement: "I'd suggest {alternative} because {evidence}" (constructive)
   - Concern: "I have concerns about this approach: {specific issue}" (direct)

3. **This applies to all executor interactions** -- responses to plan instructions, review feedback, and user input during checkpoint tasks.

**Section 5: Verification Gate** (modify existing Self-Check section)

Strengthen the existing "## Self-Check" section with explicit IDENTIFY-RUN-READ-VERIFY-CLAIM protocol:

Replace the current Self-Check content with:
```
## Self-Check (Verification Gate)

Before claiming task completion or writing SUMMARY.md, apply the verification gate:

1. **IDENTIFY:** What proves this task is done? (tests passing, file exists, command succeeds)
2. **RUN:** Execute the proof (run the command, check the file, run the test)
3. **READ:** Read the actual output (do not assume success)
4. **VERIFY:** Compare output against expected result
5. **CLAIM:** Only if VERIFY passes, mark task as complete

Banned: "should work", "probably fine", "seems correct"
Required: "Verified: {command} returned {output}, matching expected {criteria}"

After all tasks, verify all claims:
1. Check created files exist:
   [ -f "path/to/file" ] && echo "FOUND" || echo "MISSING"
2. Check commits exist:
   git log --oneline -10
3. Append ## Self-Check: PASSED or ## Self-Check: FAILED with details.
```

**IMPORTANT:** All existing content (Mode Detection, Execution Flow, Commit Protocol, Deviation Rules, Review Protocol, Summary Creation, Completion Format, Rules, Teammate Mode Protocol) stays EXACTLY as-is. The new sections are purely additive, inserted at the documented locations.
  </action>
  <verify>
Verify the modified file contains all new sections:
```bash
grep -c "## TDD Protocol" agents/mz-executor.md
grep -c "## CORTEX Classification" agents/mz-executor.md
grep -c "## Pushback Mandate" agents/mz-executor.md
grep -c "## Anti-Sycophancy" agents/mz-executor.md
grep -c "Verification Gate" agents/mz-executor.md
grep -c "IDENTIFY.*RUN.*READ.*VERIFY.*CLAIM" agents/mz-executor.md
```
All counts should be >= 1.

Verify existing sections still present:
```bash
grep -c "## Execution Flow" agents/mz-executor.md
grep -c "## Commit Protocol" agents/mz-executor.md
grep -c "## Teammate Mode Protocol" agents/mz-executor.md
```
  </verify>
  <done>
agents/mz-executor.md contains TDD Protocol (RED-GREEN-REFACTOR with stage banners, auto-exemption, violation detection, commit override), CORTEX Classification (4-domain classification with challenge blocks), Pushback Mandate (intensity scaling, evidence-based tone, 2-pushback limit), Anti-Sycophancy (banned/required phrases), and Verification Gate (IDENTIFY-RUN-READ-VERIFY-CLAIM). All existing executor content unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Forward TDD and CORTEX config flags from orchestrator to executor</name>
  <files>skills/go/SKILL.md, skills/go/executor.md</files>
  <action>
**Modify `skills/go/SKILL.md`:**

In the `<execution_rules>` block within Path A (Subagent Execution, around line 228-241) and Path B (Agent Teams Execution, around line 393-405), add two new fields after the existing review fields:

```
- TDD enabled: {true|false}
- CORTEX enabled: {true|false}
```

The values come from the config loaded in Step 2:
- `tdd_enabled = config.quality.tdd` (boolean)
- `cortex_enabled = config.quality.cortex` (boolean)

Add these to the Step 2 section where review configuration is determined (after the review config parsing block, around line 43-46). Add:
```
Determine TDD configuration:
- If `config.quality.tdd === true`: `tdd_enabled = true`
- Otherwise: `tdd_enabled = false`

Determine CORTEX configuration:
- If `config.quality.cortex === true`: `cortex_enabled = true`
- Otherwise: `cortex_enabled = false`
```

Display notices (same pattern as the review disabled notice):
- If TDD is enabled, display: `> TDD mode active: RED-GREEN-REFACTOR enforced per task`
- If CORTEX is enabled, display: `> CORTEX classification active: tasks classified before execution`

**Modify `skills/go/executor.md`:**

In the "Prompt Structure" section for both subagent and teammate modes, add the two new fields to the `<execution_rules>` template:

```
- TDD enabled: {true|false}
- CORTEX enabled: {true|false}
```

Add them after the existing `- Review mode: ...` line in both prompt structure blocks.

Also add a brief note in the "## Review Integration" section (or create a new "## Quality Integration" subsection at the end) documenting:
- TDD flag is forwarded from config and controls executor's TDD protocol
- CORTEX flag is forwarded from config and controls executor's CORTEX classification
- When TDD is active, the one-commit-per-task rule is overridden (2-3 commits per task)
- When CORTEX is active, every task gets a one-line classification before execution
  </action>
  <verify>
```bash
grep "tdd_enabled\|TDD enabled\|tdd enabled" skills/go/SKILL.md | head -5
grep "cortex_enabled\|CORTEX enabled\|cortex enabled" skills/go/SKILL.md | head -5
grep "TDD\|tdd" skills/go/executor.md | head -5
grep "CORTEX\|cortex" skills/go/executor.md | head -5
```
Both files should contain TDD and CORTEX references.
  </verify>
  <done>
/mz:go orchestrator reads `config.quality.tdd` and `config.quality.cortex`, displays activation notices, and forwards `tdd_enabled` and `cortex_enabled` flags in `<execution_rules>` to all executor prompts (both subagent and teammate modes). executor.md documents the quality flag forwarding and TDD commit override.
  </done>
</task>

</tasks>

<verification>
1. `agents/mz-executor.md` has 5 new sections: TDD Protocol, CORTEX Classification, Pushback Mandate, Anti-Sycophancy, Verification Gate
2. All existing executor content (Mode Detection, Execution Flow, Commit Protocol, Deviation Rules, Review Protocol, Summary Creation, Completion Format, Rules, Teammate Mode Protocol) is preserved unchanged
3. `skills/go/SKILL.md` forwards `tdd_enabled` and `cortex_enabled` in execution_rules for both Path A and Path B
4. `skills/go/executor.md` documents the quality flag forwarding in prompt structure templates
5. TDD Protocol includes: auto-exemption, RED/GREEN/REFACTOR banners, commit override (2-3 commits), violation detection
6. CORTEX includes: 4-domain classification, challenge block format, post-classification protocol per level
7. Anti-sycophancy includes: banned phrases, required patterns, evidence-based evaluation
8. Pushback includes: intensity scaling, direct tone, 2-pushback limit, self-challenge discretion
9. Verification gate includes: IDENTIFY-RUN-READ-VERIFY-CLAIM protocol, banned/required phrases
</verification>

<success_criteria>
- The executor agent definition contains all quality protocols that activate when config flags are passed
- The orchestrator forwards quality config flags so executors know whether TDD and CORTEX are enabled
- All protocols match the locked decisions from CONTEXT.md exactly (stage banners, auto-exemption, challenge blocks, pushback intensity, etc.)
- Existing executor behavior is completely preserved when TDD and CORTEX are disabled
</success_criteria>

<output>
After completion, create `.planning/phases/07-quality-and-debugging-skills/07-01-SUMMARY.md`
</output>
