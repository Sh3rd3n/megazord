---
phase: 07-quality-and-debugging-skills
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/discuss/SKILL.md
  - skills/debug/SKILL.md
  - skills/help/SKILL.md
autonomous: true
requirements:
  - QUAL-03
  - QUAL-04

must_haves:
  truths:
    - "/mz:discuss facilitates Socratic brainstorming that explores 5+ alternative approaches before converging"
    - "/mz:discuss outputs to CONTEXT.md when within a phase, or to .planning/brainstorms/ when standalone"
    - "/mz:debug follows four-phase methodology (reproduce, isolate, root-cause, fix) with observable state transitions"
    - "/mz:debug adapts techniques based on issue type (runtime error, build failure, test failure, performance)"
    - "/mz:help lists /mz:debug and /mz:discuss as Available (not Coming soon)"
  artifacts:
    - path: "skills/discuss/SKILL.md"
      provides: "Full Socratic brainstorming skill replacing stub"
      contains: "disable-model-invocation: false"
    - path: "skills/debug/SKILL.md"
      provides: "Full systematic debugging skill replacing stub"
      contains: "disable-model-invocation: false"
    - path: "skills/help/SKILL.md"
      provides: "Updated skill listing with debug and discuss as Available"
      contains: "Available"
  key_links:
    - from: "skills/discuss/SKILL.md"
      to: ".planning/phases/{phase}/CONTEXT.md"
      via: "Output written to CONTEXT.md format (decisions/specifics/deferred)"
      pattern: "CONTEXT.md"
    - from: "skills/debug/SKILL.md"
      to: "Four debug phases"
      via: "Sequential phase transitions with entry/exit criteria"
      pattern: "REPRODUCE.*ISOLATE.*ROOT CAUSE.*FIX"
    - from: "skills/help/SKILL.md"
      to: "skills/discuss/SKILL.md and skills/debug/SKILL.md"
      via: "Status changed from Coming soon to Available"
      pattern: "Available"
---

<objective>
Replace the /mz:discuss and /mz:debug stubs with full skill implementations. Update /mz:help to list both as Available.

Purpose: These are the two standalone thinking tools users invoke directly. /mz:discuss enables structured brainstorming before coding. /mz:debug provides systematic debugging methodology. Together with the executor-embedded protocols (Plan 07-01), they complete the quality toolset.

Output: Full `skills/discuss/SKILL.md` (Socratic brainstorming), full `skills/debug/SKILL.md` (four-phase debugging), updated `skills/help/SKILL.md`.
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@skills/discuss/SKILL.md
@skills/debug/SKILL.md
@skills/help/SKILL.md
@skills/review/SKILL.md
@skills/verify/SKILL.md
@skills/init/design-system.md
@.planning/phases/07-quality-and-debugging-skills/07-CONTEXT.md
@.planning/phases/07-quality-and-debugging-skills/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create full /mz:discuss Socratic brainstorming skill</name>
  <files>skills/discuss/SKILL.md</files>
  <action>
Replace the stub `skills/discuss/SKILL.md` with the full skill implementation. The skill enables Socratic brainstorming with minimum 5 alternative approaches explored before convergence. Follow the established skill pattern from /mz:review and /mz:verify.

**Frontmatter:**
```yaml
---
name: discuss
description: Socratic brainstorming to explore approaches before implementation
disable-model-invocation: false
---
```

**Structure (follow research patterns, honor all locked decisions):**

**Step 1: Display Banner**
Use the standard Megazord stage banner format:
```
+===============================================+
|  MEGAZORD > DISCUSS                           |
+===============================================+
```
Reference `@skills/init/design-system.md` for visual output formatting.

**Step 2: Determine Context**
Parse the user's invocation. Check for phase context:
- If user provides a phase number (e.g., `/mz:discuss 7`): target `{phase_dir}/{padded}-CONTEXT.md`
- If within an active phase (read STATE.md for current position): target current phase CONTEXT.md
- If standalone (no phase context): target `.planning/brainstorms/{YYYY-MM-DD}-{slug}.md` (create .planning/brainstorms/ if missing)

Display the context target:
```
> Output: {target file path}
```

**Step 3: Seed the Conversation**
Read the topic from the user's message (text after `/mz:discuss`). If no topic provided, ask.

Ask a probing SEED question -- not "what do you want?" but a question that:
- Demonstrates understanding of the topic
- Challenges an implicit assumption
- Opens an exploration angle

Example: For "authentication approach" -- don't ask "What kind of auth?" Instead: "Before we explore approaches -- what's your threat model? Are we protecting user data from external attackers, or also from other authenticated users?"

**Step 4: Iterative Dialogue**
Track explored approaches with an internal counter. For each exchange:
- **Listen** to the user's answer
- **Identify** an assumption in their answer and challenge it: "What if {assumption} wasn't true?"
- **Suggest** an alternative angle: "Have you considered {approach}?"
- **Build** on their ideas: "Building on that, what about {extension}?"
- **Track** each distinct approach explored

Tone: Thinking partner, not interviewer. No numbered option lists. Genuine curiosity. Build iteratively.

The dialogue continues until at least 5 distinct approaches have been explored. After 5, the skill can suggest moving to convergence but does NOT force it -- the user may want to explore more.

Soft limit: After 10-15 exchanges without convergence, explicitly suggest converging: "We've explored {N} approaches. Ready to pick a direction, or want to keep exploring?"

**Step 5: Convergence**
When the user signals readiness (or after nudge):
1. Summarize ALL explored approaches in a concise table:
   | Approach | Strengths | Weaknesses |
2. Ask the user to select one, combine elements, or explore further
3. Record their selection as the primary decision

**Step 6: Output**
Write the output file using the CONTEXT.md format (matching /gsd:discuss-phase output for compatibility):

```markdown
# {Topic} - Context

**Gathered:** {date}
**Status:** Ready for planning

<domain>
## Phase Boundary

{Concise description of the decision scope}
</domain>

<decisions>
## Implementation Decisions

{Each locked decision as a subsection with bullet points}

### Claude's Discretion
{Areas left to implementer judgment}
</decisions>

<specifics>
## Specific Ideas

{Bullet list of concrete implementation ideas from the discussion}
</specifics>

<deferred>
## Deferred Ideas

{Ideas explicitly deferred -- "None" if nothing deferred}
</deferred>
```

Display confirmation:
```
> Context written to {file path}
> {N} approaches explored, {M} decisions locked
```

**Step 7: Next Up**
```
===============================================
> Next Up
{If phase context}: **Plan this phase** -- `/mz:plan`
{If standalone}: **Use this context** -- reference the output file in your next planning session
===============================================
```

**Key behaviors (from locked decisions):**
- Minimum 5 alternative approaches (not 3 -- user decision overrides requirement minimum)
- Socratic dialogue: probing questions, not questionnaires
- Thinking partner tone: build on ideas, challenge assumptions, genuine curiosity
- Output format: CONTEXT.md compatible (decisions/specifics/deferred sections)
- Works standalone: brainstorm without any project/phase context
  </action>
  <verify>
```bash
grep "disable-model-invocation: false" skills/discuss/SKILL.md
grep -c "MEGAZORD > DISCUSS" skills/discuss/SKILL.md
grep -c "Socratic\|socratic" skills/discuss/SKILL.md
grep -c "CONTEXT.md\|brainstorms" skills/discuss/SKILL.md
grep -c "convergence\|Convergence" skills/discuss/SKILL.md
```
All counts >= 1. `disable-model-invocation` must be `false` (not `true` like the stub).
  </verify>
  <done>
/mz:discuss is a full Socratic brainstorming skill: displays banner, determines output context (phase CONTEXT.md or standalone brainstorm file), seeds with probing question, iterates through 5+ approaches with thinking-partner dialogue, converges with trade-off summary, and writes CONTEXT.md-compatible output. disable-model-invocation is false (skill is active, not a stub).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create full /mz:debug systematic debugging skill</name>
  <files>skills/debug/SKILL.md</files>
  <action>
Replace the stub `skills/debug/SKILL.md` with the full skill implementation. The skill guides systematic four-phase debugging with observable state transitions and phase banners.

**Frontmatter:**
```yaml
---
name: debug
description: Systematic four-phase debugging (reproduce, isolate, root-cause, fix)
disable-model-invocation: false
---
```

**Structure:**

**Step 1: Display Banner**
```
+===============================================+
|  MEGAZORD > DEBUG                             |
+===============================================+
```
Reference `@skills/init/design-system.md` for visual output formatting.

**Step 2: Gather Issue Context**
Parse the user's description from the text after `/mz:debug`. If insufficient, ask clarifying questions:
- What is the expected behavior?
- What is the actual behavior?
- When did it start happening?
- Any recent changes?

If a file path, error message, or test name is provided, use it as the starting point.

**Issue Type Detection:**
Categorize the issue to adapt techniques within each phase:
| Type | Signals | Adapted Approach |
|------|---------|-----------------|
| Runtime error | Stack trace, exception, crash | Trace from stack, check inputs |
| Build failure | Compile error, bundler error | Check imports, types, config |
| Test failure | Test name, assertion error | Run specific test, check assertion |
| Performance | Slow, timeout, memory | Profile, measure, compare baselines |
| Logic bug | Wrong output, incorrect behavior | Add logging, trace data flow |

Display: `> Issue type: {type}`

**Step 3: REPRODUCE**

Display phase banner:
```
+-----------------------------------------------+
|  REPRODUCE: Establishing reliable reproduction |
+-----------------------------------------------+
```

1. Run the failing test/command to confirm the issue exists
   ```bash
   {test command or reproduction command}
   ```
2. If not immediately reproducible: ask for more context, try variations, check environment
3. Document reproduction steps clearly:
   ```
   > Reproduction steps:
   1. {step}
   2. {step}
   Expected: {expected behavior}
   Actual: {actual behavior}
   ```
4. **Exit criteria:** Issue reliably reproduced with clear steps

If the issue is inherently reproducible (e.g., build error, static analysis finding): note this and move directly to ISOLATE without ceremony.

**Step 4: ISOLATE**

Display phase banner:
```
+-----------------------------------------------+
|  ISOLATE: Narrowing down the failing component |
+-----------------------------------------------+
```

1. Identify candidate components that could cause the issue
2. Use binary search strategy: disable/mock components to narrow scope
3. For runtime errors: trace the call stack to identify the failing function
4. For build errors: check the specific file/line from the error message
5. For test failures: run the specific failing test in isolation
6. Find the minimal reproduction case (fewest files, simplest input)
7. **Exit criteria:** Failing component identified

Display: `> Isolated to: {component/file/function}`

If the error includes an obvious stack trace pointing to a specific location: skip extensive binary search and proceed directly to that location.

**Step 5: ROOT CAUSE**

Display phase banner:
```
+-----------------------------------------------+
|  ROOT CAUSE: Identifying why it fails          |
+-----------------------------------------------+
```

1. Trace execution through the failing component
2. Add logging or read code to understand the data flow
3. Identify the EXACT condition causing failure (not just where, but WHY)
4. Explain causation: "This fails because {A} leads to {B} which causes {C}"
5. Distinguish correlation from causation: verify the root cause by predicting behavior changes
6. **Exit criteria:** Root cause identified and explained

Display:
```
> Root cause: {explanation}
> Evidence: {what proves this is the cause}
```

**Step 6: FIX**

Display phase banner:
```
+-----------------------------------------------+
|  FIX: Implementing and verifying the fix       |
+-----------------------------------------------+
```

1. Design the minimal fix (smallest change that addresses the root cause)
2. If TDD is enabled in project config (check `.planning/megazord.config.json`):
   - Write a regression test FIRST that fails with the current bug
   - Then implement the fix
   - Confirm the regression test passes
3. If TDD is not enabled: implement the fix directly
4. Run reproduction steps: confirm the issue is resolved
5. Run the full test suite: confirm no regressions
   ```bash
   bun test
   ```
6. Commit the fix (if within an execution context):
   ```bash
   git add {fixed_files}
   git commit -m "fix: {concise description of what was fixed}"
   ```
7. **Exit criteria:** Fix verified, reproduction passes, no regressions

**Step 7: Summary**

Display summary:
```
+===============================================+
|  Debug Complete                                |
+-----------------------------------------------+
|  Issue: {brief description}                    |
|  Type: {issue type}                            |
|  Root cause: {one-line root cause}             |
|  Fix: {one-line fix description}               |
|  Regressions: None                             |
+===============================================+
```

**Key behaviors (from locked decisions):**
- Four phases always in order: REPRODUCE -> ISOLATE -> ROOT CAUSE -> FIX
- Phase banners provide observable state transitions (user always knows which phase they're in)
- Adapt techniques based on issue type (don't force reproduce ceremony on build errors)
- Integrate with TDD when enabled (regression test before fix)
- Direct tone: "This fails because X" not "This might be related to X"
  </action>
  <verify>
```bash
grep "disable-model-invocation: false" skills/debug/SKILL.md
grep -c "MEGAZORD > DEBUG" skills/debug/SKILL.md
grep -c "REPRODUCE" skills/debug/SKILL.md
grep -c "ISOLATE" skills/debug/SKILL.md
grep -c "ROOT CAUSE" skills/debug/SKILL.md
grep -c "FIX" skills/debug/SKILL.md
```
All counts >= 1. `disable-model-invocation` must be `false`.
  </verify>
  <done>
/mz:debug is a full systematic debugging skill: displays banner, gathers issue context with type detection, then follows four sequential phases (REPRODUCE, ISOLATE, ROOT CAUSE, FIX) each with a distinct phase banner. Adapts techniques based on issue type. Integrates with TDD when enabled. Provides clear summary on completion. disable-model-invocation is false.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update help skill to list debug and discuss as Available</name>
  <files>skills/help/SKILL.md</files>
  <action>
Modify `skills/help/SKILL.md` to:

1. **Update the skill table:** Change `/mz:debug` and `/mz:discuss` from "Coming soon" to "Available":
   - `| /mz:debug | Systematic four-phase debugging | Available |`
   - `| /mz:discuss | Socratic brainstorming before implementation | Available |`

2. **Add usage examples** for the two new skills in the Usage section:
   ```
   /mz:discuss {topic}  Brainstorm approaches for a topic
   /mz:discuss 7        Brainstorm for phase 7 context
   /mz:debug {issue}    Debug an issue systematically
   /mz:debug "tests failing in auth module"  Debug with description
   ```

3. **Update the phase line** at the bottom:
   ```
   **Phase:** 7 of 8 (Quality and Debugging Skills)
   ```

4. **Update skill count:** The table should show 13 Available skills, 1 Coming soon (/mz:map only).
  </action>
  <verify>
```bash
grep "debug.*Available" skills/help/SKILL.md
grep "discuss.*Available" skills/help/SKILL.md
grep "Coming soon" skills/help/SKILL.md
grep "Phase.*7" skills/help/SKILL.md
```
debug and discuss show "Available". Only /mz:map shows "Coming soon". Phase shows 7.
  </verify>
  <done>
/mz:help lists all 13 available skills including /mz:debug and /mz:discuss. Only /mz:map remains as "Coming soon". Usage examples added for new skills. Phase reference updated to 7 of 8.
  </done>
</task>

</tasks>

<verification>
1. `skills/discuss/SKILL.md` has `disable-model-invocation: false` (not the stub's `true`)
2. `skills/discuss/SKILL.md` implements 7-step Socratic brainstorming with minimum 5 approaches
3. `skills/discuss/SKILL.md` outputs to CONTEXT.md format or .planning/brainstorms/ for standalone
4. `skills/debug/SKILL.md` has `disable-model-invocation: false` (not the stub's `true`)
5. `skills/debug/SKILL.md` implements 4-phase debugging (REPRODUCE, ISOLATE, ROOT CAUSE, FIX) with banners
6. `skills/debug/SKILL.md` adapts techniques based on issue type
7. `skills/help/SKILL.md` lists /mz:debug and /mz:discuss as "Available" (not "Coming soon")
8. Only /mz:map remains as "Coming soon" in the help listing
</verification>

<success_criteria>
- Both /mz:discuss and /mz:debug are fully functional skills (not stubs)
- /mz:discuss follows Socratic brainstorming with 5+ approaches per locked decisions
- /mz:debug follows four-phase methodology with observable state transitions per locked decisions
- /mz:help accurately reflects the current state of all skills
- All skills use the standard Megazord banner format and design system
</success_criteria>

<output>
After completion, create `.planning/phases/07-quality-and-debugging-skills/07-02-SUMMARY.md`
</output>
