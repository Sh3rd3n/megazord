---
phase: 04-subagent-execution-and-atomic-commits
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - agents/mz-executor.md
  - skills/go/SKILL.md
  - skills/go/executor.md
  - skills/help/SKILL.md
  - commands/go.md
autonomous: true
requirements: [PROJ-08, AGNT-02]

must_haves:
  truths:
    - "/mz:go reads current phase plans via CLI tools and spawns executor subagents via Task tool"
    - "Executor subagent commits each task atomically with conventional commit format {type}({phase}-{plan}): {description}"
    - "Executor subagent does NOT add Co-Authored-By lines to commits"
    - "Executor subagent stages files individually (never git add . or git add -A)"
    - "Executor subagent creates SUMMARY.md after all tasks complete"
    - "Wave-based execution: plans without mutual dependencies run in parallel within a wave"
    - "When no plans exist for the current phase, /mz:go shows error directing to /mz:plan"
    - "After execution, orchestrator updates STATE.md and ROADMAP.md via CLI tools"
    - "The Task tool subagent pipeline is the primary and only execution path (graceful degradation IS the default)"
    - "/mz:go supports --tasks and --from flags for partial execution"
  artifacts:
    - path: "agents/mz-executor.md"
      provides: "Plan executor agent definition with commit protocol, deviation rules, summary creation"
      min_lines: 150
    - path: "skills/go/SKILL.md"
      provides: "Full /mz:go execution orchestrator with 7-step pipeline"
      min_lines: 200
    - path: "skills/go/executor.md"
      provides: "Supporting file with execution protocol reference for the skill"
      min_lines: 40
    - path: "skills/help/SKILL.md"
      provides: "Updated help with /mz:go as Available (not Coming soon)"
      min_lines: 50
    - path: "commands/go.md"
      provides: "Autocomplete proxy for /mz:go"
      min_lines: 3
  key_links:
    - from: "skills/go/SKILL.md"
      to: "agents/mz-executor.md"
      via: "Reads agent definition and embeds in Task prompt"
      pattern: "agents/mz-executor.md"
    - from: "skills/go/SKILL.md"
      to: "src/cli/commands/plan-tools.ts"
      via: "Calls CLI tools for plan metadata"
      pattern: "megazord.mjs tools plan"
    - from: "skills/go/SKILL.md"
      to: "src/cli/commands/state.ts"
      via: "Calls CLI tools for state updates"
      pattern: "megazord.mjs tools state advance-plan"
    - from: "skills/go/SKILL.md"
      to: "skills/go/executor.md"
      via: "@-reference to supporting file"
      pattern: "@skills/go/executor.md"
---

<objective>
Create the executor agent definition and the full /mz:go orchestration skill that transforms planned tasks into executed code with atomic commits. The skill reads plans via CLI tools, computes wave order, spawns executor subagents per-plan via the Task tool, tracks progress, and updates project state. The executor agent enforces the one-task-one-commit discipline with conventional commit format.

Purpose: This is the execution engine of Megazord -- the bridge between "I have a plan" and "I have working code." It completes Phase 4's requirement that `/mz:go` spawns subagents and each task produces exactly one commit. The Task tool pipeline IS the graceful degradation path for AGNT-02.

Output: `agents/mz-executor.md`, `skills/go/SKILL.md`, `skills/go/executor.md`, updated `skills/help/SKILL.md`, `commands/go.md`
</objective>

<execution_context>
@/Users/sh3rd3n/.claude/get-shit-done/workflows/execute-plan.md
@/Users/sh3rd3n/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@agents/mz-researcher.md
@agents/mz-planner.md
@skills/plan/SKILL.md
@skills/plan/agents.md
@skills/go/SKILL.md
@skills/help/SKILL.md
@skills/init/design-system.md
@.planning/phases/04-subagent-execution-and-atomic-commits/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create executor agent definition</name>
  <files>
agents/mz-executor.md
  </files>
  <action>
Create `agents/mz-executor.md` modeled on GSD's gsd-executor.md but adapted for Megazord conventions. This agent is spawned by the /mz:go skill to execute a single PLAN.md file.

Structure the agent definition with these sections:

**# Megazord Plan Executor**

**## Your Objective**
Execute a PLAN.md file completely: implement each task, verify each task, commit each task atomically, create SUMMARY.md when done.

**## Input**
You receive embedded inline in the Task prompt:
- The full PLAN.md content (frontmatter + tasks)
- The executor protocol (from skills/go/executor.md)
- megazord.config.json content (for quality settings)
- Phase number and plan number
- Commit format rules

**## Execution Flow**
1. Record start time (`date -u +"%Y-%m-%dT%H:%M:%SZ"` and `date +%s`)
2. Read the `<context>` files listed in the plan using your Read tool (these are file paths, read them directly -- do NOT rely on @-references)
3. For each task in `<tasks>`:
   a. Execute the task following `<action>` instructions
   b. Run `<verify>` checks to confirm completion
   c. Confirm `<done>` criteria are met
   d. Stage ONLY the files listed in `<files>` individually: `git add path/to/file.ts` (NEVER use `git add .` or `git add -A`)
   e. Commit with format: `{type}({phase}-{plan}): {concise description}` using a HEREDOC for the message body
   f. Record commit hash: `git rev-parse --short HEAD`
4. After all tasks: create SUMMARY.md
5. Return structured completion message

**## Commit Protocol**
- One commit per task, no exceptions
- Do NOT add Co-Authored-By lines (user decision: commits appear clean)
- Stage files individually, only the files listed in `<files>` for that task
- Commit type table:
  | Type | When |
  |------|------|
  | `feat` | New feature, endpoint, component, library |
  | `fix` | Bug fix, error correction |
  | `test` | Test-only changes (TDD RED) |
  | `refactor` | Code cleanup, no behavior change |
  | `chore` | Config, tooling, dependencies |
- Format: `{type}({phase}-{plan}): {concise task description}`
- Use HEREDOC for commit messages to ensure correct formatting:
  ```bash
  git commit -m "$(cat <<'EOF'
  feat(04-01): create plan parsing library

  - Plan frontmatter parsing via gray-matter
  - Wave computation and conflict detection
  EOF
  )"
  ```

**## Deviation Rules**
Simplified from GSD (Megazord is full-auto, no checkpoints in Phase 4):

- **Rule 1 - Auto-fix bugs:** Code doesn't work as intended. Fix inline, track in summary.
- **Rule 2 - Auto-add missing critical:** Missing error handling, validation, security. Fix inline.
- **Rule 3 - Auto-fix blocking:** Missing dependency, wrong types, broken imports. Fix inline.
- **Rule 4 - Log architectural issues:** Significant structural changes needed. Do NOT stop. Log as deferred item and continue. (Phase 4 is full-auto per user decision.)

Scope boundary: Only fix issues caused by current task's changes. Pre-existing issues go to deferred-items.md.
Fix attempt limit: 3 attempts per task. After that, document in SUMMARY and move on.

**## Summary Creation**
After all tasks complete, create `{phase_dir}/{padded}-{plan}-SUMMARY.md` using the Write tool (never heredoc).

Include standard frontmatter: phase, plan, subsystem, tags, dependency graph, tech-stack, key-files, key-decisions, patterns-established, requirements-completed, metrics.

Include body sections: Performance, Accomplishments, Task Commits, Files Created/Modified, Decisions Made, Deviations from Plan, Issues Encountered, User Setup Required, Next Phase Readiness, Self-Check.

**## Self-Check**
After writing SUMMARY.md, verify:
1. Created files exist (check with Bash)
2. Commits exist (git log --oneline)
3. Append `## Self-Check: PASSED` or `## Self-Check: FAILED` with details

**## Completion Format**
Return this exact structure:
```markdown
## PLAN COMPLETE

**Plan:** {phase}-{plan}
**Tasks:** {completed}/{total}
**SUMMARY:** {path to SUMMARY.md}

**Commits:**
- {hash}: {message}
- {hash}: {message}

**Duration:** {time}
```

**## Rules**
- Do NOT update STATE.md or ROADMAP.md -- the orchestrator handles state updates
- Do NOT create docs() commits -- the orchestrator handles metadata commits
- Do NOT use @file references -- read files directly with Read tool
- ALWAYS use the Write tool for file creation (never Bash heredoc)
- ALWAYS use bun/bunx for JavaScript/TypeScript operations (never npm/npx)
- Read all `<context>` files at the start before executing tasks
  </action>
  <verify>
Verify agents/mz-executor.md exists and contains: "Megazord Plan Executor", "Commit Protocol", "Deviation Rules", "Summary Creation", "PLAN COMPLETE" return format. Must be at least 150 lines.
  </verify>
  <done>
agents/mz-executor.md is a complete executor agent definition that a Task tool subagent can follow to execute a PLAN.md file with per-task atomic commits, deviation handling, summary creation, and structured return format.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /mz:go skill, supporting files, and update help</name>
  <files>
skills/go/SKILL.md
skills/go/executor.md
skills/help/SKILL.md
commands/go.md
  </files>
  <action>
**1. Create `skills/go/executor.md`** -- supporting file referenced by the skill with execution protocol details:

Content should cover:
- Spawning protocol: how the orchestrator reads agent definition and plan content, embeds inline in Task prompt
- Prompt structure for executor: `<agent_role>`, `<plan>`, `<config>`, `<execution_rules>` sections
- Critical constraint: @file references do NOT work across Task boundaries (same as plan/agents.md)
- Progress tracking: orchestrator displays plan-level progress, task-level is visible in subagent output
- State update protocol: only orchestrator updates STATE.md/ROADMAP.md, never executors
- Failure handling: executor returns structured failure, orchestrator stops after failed wave

**2. Replace `skills/go/SKILL.md`** (currently an informative stub) with the full execution orchestrator:

Frontmatter:
```yaml
---
name: go
description: Execute the current phase plan with subagent delegation
disable-model-invocation: false
---
```

Reference supporting files:
```
Reference @skills/init/design-system.md for visual output formatting.
Reference @skills/go/executor.md for execution protocol and spawning patterns.
```

**Step 1: Display Banner**
```
+===============================================+
|  MEGAZORD > EXECUTE                           |
+===============================================+
```
(Use the standard MEGAZORD banner format from design-system.md)

**Step 2: Load Context + Validate**
- Read `.planning/megazord.config.json`. If missing -> error box suggesting /mz:init. Stop.
- Read `.planning/STATE.md` for current position.
- Read `.planning/ROADMAP.md` for phase details.
- Parse user arguments from the message after /mz:go:
  - `--tasks N,M` -- execute only specific plan numbers
  - `--from N` -- start from plan N, skip earlier plans
  - `--dry-run` -- show execution plan without running
- Determine the plugin path for CLI commands (the Megazord plugin directory, resolved from the skill's location).

**Step 3: Find Plans**
- Determine current phase from STATE.md position. Compute phase directory path.
- List plans: `node {plugin_path}/bin/megazord.mjs tools plan list --phase-dir {dir}`
- If no plans returned: display error box "No plans found for Phase {N}. Run /mz:plan to create plans first." Stop.
- Get incomplete plans: `node {plugin_path}/bin/megazord.mjs tools plan incomplete --phase-dir {dir}`
- If all plans complete (incomplete list empty): display "Phase {N} already complete. Run /mz:verify to validate." Stop.
- Compute waves: `node {plugin_path}/bin/megazord.mjs tools plan waves --phase-dir {dir}`
- Check conflicts: `node {plugin_path}/bin/megazord.mjs tools plan conflicts --phase-dir {dir}`

Display execution plan:
```
> Execution Plan
  Phase {N}: {Name}
  Plans: {total} ({incomplete} remaining)
  Waves: {wave_count}

  Wave 1: {plan_list} (parallel/sequential)
  Wave 2: {plan_list}
```

If conflicts detected, note which plans will be serialized and why.

**Step 4: Apply Execution Filters**
- If `--tasks N,M` provided: filter incomplete plans to only include the specified plan numbers.
- If `--from N` provided: filter to plans with number >= N. Verify plans before N have SUMMARY.md files (completed). If not, warn but continue.
- If `--dry-run` provided: display the execution plan from Step 3 and stop. Do not execute.
- If neither flag provided: execute all incomplete plans (default).

**Step 5: Execute Waves**
For each wave (sequential):
  Display: `> Wave {N}`

  Determine plan execution order within wave:
  - Parse conflict analysis from Step 3
  - If no conflicts: plans can run in parallel (spawn all Task calls for this wave)
  - If conflicts: serialize conflicting plans, parallelize the rest

  For each plan in the wave:
    Display: `  * Plan {NN}: {objective from plan file}...`

    1. Read the full PLAN.md content
    2. Read agents/mz-executor.md content
    3. Read megazord.config.json content
    4. Compose the Task prompt with all content inline:
       ```
       <agent_role>
       {content of agents/mz-executor.md}
       </agent_role>

       <plan>
       {full content of PLAN.md}
       </plan>

       <config>
       {content of megazord.config.json}
       </config>

       <execution_rules>
       - Phase: {phase_number}
       - Plan: {plan_number}
       - Phase directory: {phase_dir}
       - Commit format: {type}({phase}-{plan}): {description}
       - Do NOT add Co-Authored-By lines to commits
       - Stage files individually (never git add . or git add -A)
       - One commit per task, no exceptions
       - Create SUMMARY.md at {phase_dir}/{padded}-{plan}-SUMMARY.md
       - Do NOT update STATE.md or ROADMAP.md
       - Use bun/bunx for all JS/TS operations (never npm/npx)
       </execution_rules>
       ```
    5. Spawn executor via Task tool:
       - `subagent_type`: "general-purpose"
       - `description`: "Execute Plan {phase}-{plan}: {brief objective}"
    6. Wait for completion
    7. Parse the structured result (look for "## PLAN COMPLETE" in the response)
    8. Display result: `  > Plan {NN}: {duration}, {N} tasks, {commit_count} commits`

  After ALL plans in the wave complete:
    For each completed plan in this wave:
    - Advance plan counter: `node {plugin_path}/bin/megazord.mjs tools state advance-plan`
    - Record metric: `node {plugin_path}/bin/megazord.mjs tools state record-metric --phase {phase} --plan {plan} --duration {duration} --tasks {count} --files {count}`
    - Extract decisions from SUMMARY.md and add each: `node {plugin_path}/bin/megazord.mjs tools state add-decision --phase {phase} --decision "{decision}"`
    - Update session: `node {plugin_path}/bin/megazord.mjs tools state update-session --last-session {date} --stopped-at "Completed {phase}-{plan}" --resume-file "{next_plan_path or phase_dir}"`

  If a plan FAILS in this wave:
    - Display failure: `  X Plan {NN}: FAILED -- {error description}`
    - Save error output to `{phase_dir}/{padded}-{plan}-ERROR.md`
    - Update session with last error: `node {plugin_path}/bin/megazord.mjs tools state update-session --last-error "Plan {NN} failed: {brief error}"`
    - Wait for other plans in the wave to finish (they may still succeed)
    - STOP after this wave. Do NOT start the next wave.
    - Display: "Execution stopped after wave {N} due to failure. Run /mz:go to resume from the first incomplete plan."

**Step 6: Update Roadmap**
After all waves complete (or after stopping):
- Update ROADMAP.md plan completion entries to reflect completed plans
- Read each completed plan's SUMMARY.md to verify it exists
- In ROADMAP.md progress table, update the plan counts for this phase

**Step 7: Post-Execution Summary**
Display summary using design system action box:
```
+===============================================+
|  Execution Complete                           |
+===============================================+
|  Phase {N}: {Name}                            |
|  Plans: {completed}/{total}                   |
|  Commits: {total_commits}                     |
|  Duration: {total_time}                       |
|                                               |
|  Wave 1: Plan 01 ({time}), Plan 02 ({time})  |
|  Wave 2: Plan 03 ({time})                     |
+===============================================+
```

Display Next Up block:
- If all plans complete: "Phase complete. Use /mz:verify to validate."
- If some plans remain (failure case): "Run /mz:go to resume execution."
- If all phases complete: "All phases complete! Project delivered."

**3. Update `skills/help/SKILL.md`**
- Move /mz:go from "Coming soon" to "Available" section
- Update its description to: "Execute the current phase plan with subagent delegation"
- Adjust skill counts (9 Available, 5 Coming soon)

**4. Create `commands/go.md`**
Autocomplete proxy file matching the pattern of existing command files:
```yaml
---
name: go
description: Execute the current phase plan with subagent delegation
---
Invoke the mz:go skill.
```

**Error Handling (embedded in skill steps):**
- Config missing -> Step 2 error box, suggest /mz:init
- No plans -> Step 3 error box, suggest /mz:plan
- All plans complete -> Step 3 info message, suggest /mz:verify
- Plan execution failure -> Step 5 failure handling, stop after wave, suggest /mz:go to resume
- State update failure -> Log warning, don't block (plans already committed)
  </action>
  <verify>
1. skills/go/SKILL.md exists, has `disable-model-invocation: false`, contains 7 steps, references executor.md and design-system.md
2. skills/go/executor.md exists, covers spawning protocol and prompt structure
3. agents/mz-executor.md is referenced in skills/go/SKILL.md text
4. skills/help/SKILL.md shows /mz:go as Available (not Coming soon)
5. commands/go.md exists with correct frontmatter
6. No skill references npm/npx (only bun/bunx)
  </verify>
  <done>
/mz:go skill is a complete 7-step execution orchestrator that reads plans via CLI tools, computes wave order, spawns executor subagents via Task tool with inline context, tracks progress, handles failures, updates state, and presents results. The executor agent definition enforces per-task atomic commits with conventional commit format. Help is updated. Autocomplete proxy exists.
  </done>
</task>

</tasks>

<verification>
1. agents/mz-executor.md exists with commit protocol, deviation rules, summary creation (at least 150 lines)
2. skills/go/SKILL.md is a full orchestrator (not a stub), disable-model-invocation: false, at least 200 lines
3. skills/go/executor.md exists with spawning protocol documentation
4. skills/help/SKILL.md shows 9 Available skills (help, init, settings, plan, status, pause, resume, quick, go) and 5 Coming soon
5. commands/go.md exists as autocomplete proxy
6. No references to npm/npx anywhere in new files (only bun/bunx)
7. /mz:go skill references CLI tools: megazord.mjs tools plan list, tools plan waves, tools plan incomplete, tools plan conflicts, tools state advance-plan, tools state record-metric, tools state add-decision
8. Executor agent specifies: no Co-Authored-By, individual file staging, HEREDOC commit format, conventional commits
</verification>

<success_criteria>
The /mz:go skill can be invoked to execute planned tasks via Task tool subagents. The executor agent definition enforces one commit per task with conventional commit format and no Co-Authored-By. Wave-based execution runs independent plans in parallel. When no plans exist, a clear error directs to /mz:plan. The Task tool pipeline is the primary execution path, satisfying AGNT-02's graceful degradation requirement. State updates are handled by the orchestrator, not the executors.
</success_criteria>

<output>
After completion, create `.planning/phases/04-subagent-execution-and-atomic-commits/04-02-SUMMARY.md`
</output>
